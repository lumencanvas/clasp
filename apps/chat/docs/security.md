# Security Model

## Authentication

### Auth Endpoints

The relay exposes three HTTP endpoints on the auth port (default 7350):

| Endpoint | Purpose | Returns |
|----------|---------|---------|
| `POST /auth/register` | Create account with username/password | `{ token, user_id, username }` |
| `POST /auth/login` | Authenticate existing user | `{ token, user_id, username }` |
| `POST /auth/guest` | Create ephemeral guest session | `{ token, user_id, username }` |

### Password Hashing

- **Server-side**: Argon2id (via the `argon2` Rust crate with default params: 19MB memory, 2 iterations)
- **Client-side** (room/namespace passwords): PBKDF2-SHA256 with 600,000 iterations (OWASP 2024 recommendation)

### Token System

Auth endpoints return a CPSK (Capability Pre-Shared Key) token. The token:
- Is generated by `CpskValidator::generate_token()` in the `clasp-core` crate
- Expires after 86,400 seconds (24 hours)
- Contains the user's scoped permissions (see Authorization below)
- Is validated on every WebSocket HELLO handshake
- Is stored in `localStorage` as `clasp-chat-token`

### Rate Limiting

Authentication endpoints are rate-limited to prevent brute force attacks:

| Endpoint | Max Attempts | Window | Key |
|----------|-------------|--------|-----|
| `/auth/login` | 5 | 15 minutes | IP address AND username (both checked) |
| `/auth/register` | 10 | 15 minutes | IP address |
| `/auth/guest` | 10 | 15 minutes | IP address |

Rate limiting uses a sliding window algorithm. On successful login, the attempt counter is cleared.

### User ID Validation

Client-supplied `user_id` values (optional on register and guest) are validated:
- Must be 1-64 characters
- Only alphanumeric, hyphens, and underscores allowed
- Must not already exist in the users table (prevents identity hijacking)

If no `user_id` is provided, the server generates one: `u-{timestamp}-{random}`.

## Authorization (Scopes)

Every CLASP operation is checked against the authenticated user's scope list. Scopes are granted at token issuance and follow the format `action:pattern`.

### Scope Enforcement Flow

```
Client sends SET/PUBLISH/SUBSCRIBE
        │
        v
  CLASP Router receives message
        │
        v
  Extract operation type:
    SET/PUBLISH -> requires write scope
    SUBSCRIBE   -> requires explicit read scope (strict check, write scopes do NOT grant subscribe access)
        │
        v
  Match address against scope patterns
  (glob matching: * = single segment, ** = recursive)
        │
        ├── Match found -> Allow operation
        └── No match -> Reject with ERROR
```

### Security-Critical Scope Restrictions

| Path | Scope | Rationale |
|------|-------|-----------|
| `crypto/pubkey/{userId}` | Write restricted to own userId | Prevents MITM: users can only publish their own ECDH public key |
| `crypto/proof/{userId}` | Write restricted to own userId | Prevents proof forgery: users can only publish their own password proof |
| `presence/{userId}` | Write restricted to own userId | Prevents presence spoofing |
| `typing/{userId}` | Write restricted to own userId | Prevents typing indicator spoofing |
| `user/{userId}/**` | Write restricted to own userId | Prevents profile impersonation |
| `user/*/dms/*` | Write open + WriteValidator | DM notifications require `fromId` matching session identity and server-verified friendship |
| `requests/**` | Write open + WriteValidator | Friend requests require path `fromId` segment and value `fromId` matching session identity |

### DM Authorization

DMs use a four-layer authorization model:

1. **UI gate**: The "Message" button in `UserProfilePopup` is only shown when `friendStatus === 'friend'`. This prevents unsolicited DMs from non-friends.
2. **Client-side guard**: `isFriend()` check in `useRooms.js` `createDM()` prevents DM creation even if the UI gate is bypassed.
3. **Scope gate**: The `write:/chat/user/*/dms/*` scope allows any authenticated user to write a DM notification to another user's inbox. The wildcard `*` matches a single path segment only (no slash traversal), and user IDs are validated to alphanumeric + hyphens/underscores.
4. **Server-side WriteValidator**: Requires `fromId` field matching session identity (prevents impersonation), requires friendship (checks state for `/chat/user/{a}/friends/{b}`), prevents unsolicited DMs from non-friends at the server level.

The DM message content itself flows through `/chat/room/*/messages` (a separate scope). The DM inbox entry is just a notification containing `{ fromId, fromName, roomId, timestamp }`.

### Known Limitations (Deferred to Phase 2)

- Per-room read scoping requires server-side room membership tracking (Phase 2)
- Admin/ban/meta paths enforced server-side by WriteValidator; namespace metadata still client-side only

## E2E Encryption

### Cryptographic Primitives

| Primitive | Algorithm | Key Size | Purpose |
|-----------|-----------|----------|---------|
| Message encryption | AES-256-GCM | 256-bit | Encrypt/decrypt chat messages |
| Key exchange | ECDH P-256 | 256-bit | Establish shared secret between peers |
| Key derivation | HKDF-SHA256 | 256-bit | Derive AES key from ECDH shared secret |
| Message signing | ECDSA P-256-SHA256 | 256-bit | Sign/verify chat messages |
| Key fingerprint | SHA-256 | 256-bit | TOFU fingerprint for peer signing keys |
| Password hashing | PBKDF2-SHA256 | 256-bit | Hash room/namespace passwords (client-side) |
| IV generation | `crypto.getRandomValues` | 96-bit | Random IV per encryption operation |

All cryptographic operations use the Web Crypto API (`crypto.subtle`), which provides:
- Hardware-accelerated implementations where available
- Non-extractable private keys (ECDH private keys cannot be exported from Web Crypto)
- Constant-time comparison for authentication tags (AES-GCM)

### Key Lifecycle

```
1. Room Created with encryption=true
   │
   v
2. Creator generates AES-256-GCM room key
   ├── Stored in useCrypto's in-memory Map (roomKeys)
   └── Exported to JWK, persisted to IndexedDB
   │
   v
3. Creator publishes ECDH public key to CLASP state
   └── /chat/room/{roomId}/crypto/pubkey/{creatorId}
   │
   v
4. New member joins, doesn't have room key
   ├── Subscribes to key exchange: /chat/room/{roomId}/crypto/keyex/{userId}
   └── Publishes own ECDH public key: /chat/room/{roomId}/crypto/pubkey/{userId}
   │
   v
5. Existing key holder sees new public key (subscription fires)
   ├── Derives shared secret: ECDH + HKDF-SHA256
   ├── Encrypts room key with shared secret (AES-GCM)
   └── Emits encrypted key to: /chat/room/{roomId}/crypto/keyex/{newMemberId}
   │
   v
6. New member receives encrypted key
   ├── Derives same shared secret: ECDH + HKDF-SHA256
   ├── Decrypts room key
   ├── Stores in-memory and IndexedDB
   └── Can now encrypt/decrypt messages
```

### HKDF Key Derivation

The ECDH shared secret is not used directly as an AES key. Instead, it passes through HKDF-SHA256 for proper key derivation:

```
ECDH deriveBits (256-bit raw shared secret)
        │
        v
  Import as HKDF key material
        │
        v
  HKDF-SHA256(
    key:  raw ECDH bits,
    salt: 32 zero bytes,
    info: "clasp-chat-keyex-v1"    // domain separation
  )
        │
        v
  AES-256-GCM key (for encrypting the room key transfer)
```

### Key Rotation

When a user is banned from an encrypted room:

1. Admin calls `banUser()` in `useAdmin`
2. `removePeerKey(roomId, bannedUserId)` removes the banned user's cached ECDH public key
3. `rotateRoomKey(roomId)` generates a new AES-256-GCM room key
4. New key is persisted to IndexedDB
5. New ECDH public key is published (triggers re-exchange)
6. New key is proactively distributed to all cached peers (excluding the banned user)

The banned user retains the old key and can decrypt messages sent before the rotation, but cannot decrypt messages encrypted with the new key.

### Password-Protected Room Key Gating

For rooms with a password, the key exchange adds a proof verification step:

```
Joining user                                Key holder
     │                                           │
     │  1. Hash(password, room salt)              │
     │  2. Publish proof:                         │
     │     /chat/room/{rid}/crypto/proof/{uid}    │
     │     { hash, timestamp }                    │
     │                                            │
     │  3. Publish ECDH pubkey                    │
     │     (triggers key exchange)                │
     │                                            │
     │                                  4. See new pubkey
     │                                  5. Check passwordRooms map
     │                                  6. Subscribe to proof path
     │                                  7. Compare proof.hash === expectedHash
     │                                     ├── Match: proceed with key exchange
     │                                     └── No match / timeout (2s): skip
     │                                            │
     │<──────── Encrypted room key ───────────────│
```

### Message Encryption Format

Encrypted messages are emitted with this structure:

```json
{
  "from": "Alice",
  "fromId": "session-abc",
  "msgId": "1708123456789-a1b2c3",
  "text": "<base64 AES-GCM ciphertext>",
  "iv": "<base64 12-byte IV>",
  "encrypted": true,
  "timestamp": 1708123456789,
  "avatarColor": "#457b9d",
  "type": "text"
}
```

The `encrypted: true` flag tells receiving clients to decrypt before display. If an image is attached, it is separately encrypted in `encryptedImage`/`imageIv` fields.

### Decryption Error Handling

AES-GCM provides authenticated encryption. If the authentication tag fails (indicating tampering or wrong key):
- `OperationError` is caught and logged with a tampering warning
- The message displays as `[encrypted message - key unavailable]`
- Distinct from "no key" (returns null immediately) -- both cases show the placeholder

### Local Key Storage

Room keys are persisted in IndexedDB (`clasp-chat` database, `crypto-keys` object store) as JWK objects. Keys are stored unencrypted.

**Known limitation**: Device seizure exposes all room keys. Local key encryption (derived from user password) is a Phase 3 remediation item.

## Message Signing

The `useSigning` composable provides ECDSA P-256-SHA256 message signatures to authenticate message authorship.

### How It Works

1. On initialization, `useSigning` generates a non-extractable ECDSA P-256 keypair via the Web Crypto API
2. The public key (as JWK) is published to `/chat/user/{userId}/signingKey` along with the algorithm identifier and timestamp
3. When sending a message, `useChat` calls `signMessage(payload)` which:
   - Creates a canonical form: `{text, fromId, msgId, timestamp}`
   - Signs the canonical JSON with the private key
   - Attaches the base64 signature to the outgoing message
4. On receipt, `useChat` calls `verifyMessage(payload)` which:
   - Fetches the sender's public key from CLASP state (with 2s timeout and deduplication)
   - Caches peer signing keys in memory
   - Returns `'verified'` (valid signature), `'failed'` (invalid signature), or `'unknown'` (no key available)

### Signing Key Storage

- **Private key**: Held in memory only (non-extractable `CryptoKey`). Lost on page refresh; a new keypair is generated each session.
- **Public key**: Published to CLASP state and persisted in IndexedDB via `saveSigningKey()`.
- **Peer keys**: Cached in-memory Map, fetched from CLASP on first encounter.

## TOFU Key Verification

The `useKeyVerification` composable implements Trust On First Use (TOFU) verification for peer signing keys.

### How It Works

1. When a peer's signing key is first seen, its SHA-256 fingerprint is computed and stored in IndexedDB (`tofu-keys` store via `saveTofuKey()`)
2. On subsequent encounters, the stored fingerprint is compared against the current key
3. If the fingerprint matches, the key is trusted silently
4. If the fingerprint has changed, a warning is surfaced via the `keyWarnings` reactive Map

### Key Change Warnings

- Key changes are displayed by `KeyChangeWarning.vue` in the chat view
- Users can **accept** the new key (updates the stored fingerprint) or **dismiss** the warning (hides it without updating)
- `getRoomWarnings(roomId)` returns active warnings for a specific room
- Warnings are scoped per `roomId:userId` pair

### Verification API

| Function | Description |
|----------|-------------|
| `verifyKey(roomId, userId, publicKeyJwk, displayName)` | Returns `{trusted, firstSeen, changed, fingerprint}` |
| `acceptKeyChange(roomId, userId)` | Updates stored fingerprint to current key |
| `dismissWarning(roomId, userId)` | Hides warning without updating fingerprint |
| `getStoredFingerprint(roomId, userId)` | Retrieves stored fingerprint for display |
| `getRoomWarnings(roomId)` | Returns active key change warnings for a room |

## CORS Configuration

The auth HTTP server supports configurable CORS:

- **With `--cors-origin`**: Restricts `Access-Control-Allow-Origin` to the specified origins (comma-separated). Only `POST` and `OPTIONS` methods are allowed.
- **Without `--cors-origin`**: Falls back to permissive CORS (for development).

Production deployments should always set `--cors-origin` to the chat frontend's domain.

## Threat Model

### What the system protects against

| Threat | Protection |
|--------|-----------|
| Passive network eavesdropper | TLS (Caddy) + E2E encryption |
| Password brute force | Argon2id server-side, rate limiting on login |
| Identity impersonation via scopes | userId-restricted write paths for presence, typing, crypto |
| MITM key injection | Crypto pubkey paths restricted to own userId |
| Password proof bypass | Hash comparison against room's expected hash |
| Mass account creation | Registration rate limiting per IP |
| Path traversal in namespaces | `sanitizeNsPath()` rejects `..`, `*`, `**`, non-alphanumeric |
| User ID format injection | `is_valid_user_id()` validates alphanumeric + hyphens/underscores |
| Cross-origin token theft | Configurable CORS with explicit origin allowlist |

### Known limitations

| Limitation | Description | Remediation Phase |
|------------|-------------|-------------------|
| Per-room read scoping | Granular read scopes in place, but per-room access requires membership tracking | Phase 2 |
| Namespace admin enforcement | Room admin/ban/meta enforced server-side by WriteValidator; namespace admin still client-side | Phase 2 |
| No forward secrecy | Single ECDH key pair per session, static room keys | Phase 3 |
| Unencrypted local keys | IndexedDB stores room key JWKs in plaintext | Phase 3 |
| Plaintext state snapshot | Relay writes all state to disk as JSON | Phase 3 |

## Security Audit History

A comprehensive security audit was performed on 2026-02-18 covering crypto, auth, access control, namespaces, transport, and storage. The following findings were remediated:

| ID | Finding | Severity | Fix |
|----|---------|----------|-----|
| C1 (partial) | Relay can MITM key exchange | Critical | Restricted crypto pubkey writes to own userId |
| C3 | Client-supplied user_id enables identity hijacking | Critical | Reject user_ids already in users table; validate format |
| C4 | Password proof doesn't verify hash | Critical | Compare proof.hash against expected room passwordHash |
| H2 | CORS permissive on auth | High | Configurable `--cors-origin` CLI arg |
| H3 | ECDH derives directly to AES without KDF | High | Added HKDF-SHA256 with domain separation |
| H7 | No login brute-force protection | High | Per-IP + per-username rate limiting |
| M2 | user_id with invalid characters | Medium | `is_valid_user_id()` validation |
| M5 | PBKDF2 iterations too low | Medium | Increased from 100k to 600k |
| M6 | No registration rate limiting | Medium | Per-IP rate limiting on register/guest |
| M7 | ECDH private key marked extractable | Medium | Set `extractable: false` on import |
| L4 | Silent decryption failure masks tampering | Low | Log AES-GCM OperationError with tampering warning |
| NEW-3 | Subscription leak in proof timeout | Bug | Added `settled` flag pattern for cleanup |
| S1 | Global read scope leaks all DM/friend data | Critical | Replaced `read:/chat/**` with 5 granular read scopes; added `has_strict_read_scope()` for SUBSCRIBE |
| S2 | Anonymous snapshot leaks room internals | High | Removed `!user_id.is_empty()` guard from room membership filter |
| S3 | Missing fromId allows unattributed DMs | High | fromId now required on DM notifications and friend requests |
| S4 | No server-side friendship check on DMs | Critical | WriteValidator checks friendship state before allowing DM writes |
| S5 | fromId spoofing on DMs and friend requests | High | WriteValidator validates fromId matches session subject |
