# Security Model

## Authentication

### Auth Endpoints

The relay exposes three HTTP endpoints on the auth port (default 7350):

| Endpoint | Purpose | Returns |
|----------|---------|---------|
| `POST /auth/register` | Create account with username/password | `{ token, user_id, username }` |
| `POST /auth/login` | Authenticate existing user | `{ token, user_id, username }` |
| `POST /auth/guest` | Create ephemeral guest session | `{ token, user_id, username }` |

### Password Hashing

- **Server-side**: Argon2id (via the `argon2` Rust crate with default params: 19MB memory, 2 iterations)
- **Client-side** (room/namespace passwords): PBKDF2-SHA256 with 600,000 iterations (OWASP 2024 recommendation)

### Token System

Auth endpoints return a CPSK (Capability Pre-Shared Key) token. The token:
- Is generated by `CpskValidator::generate_token()` in the `clasp-core` crate
- Expires after 86,400 seconds (24 hours)
- Contains the user's scoped permissions (see Authorization below)
- Is validated on every WebSocket HELLO handshake
- Is stored in `localStorage` as `clasp-chat-token`

### Rate Limiting

Authentication endpoints are rate-limited to prevent brute force attacks:

| Endpoint | Max Attempts | Window | Key |
|----------|-------------|--------|-----|
| `/auth/login` | 5 | 15 minutes | IP address AND username (both checked) |
| `/auth/register` | 10 | 15 minutes | IP address |
| `/auth/guest` | 10 | 15 minutes | IP address |

Rate limiting uses a sliding window algorithm. On successful login, the attempt counter is cleared.

### User ID Validation

Client-supplied `user_id` values (optional on register and guest) are validated:
- Must be 1-64 characters
- Only alphanumeric, hyphens, and underscores allowed
- Must not already exist in the users table (prevents identity hijacking)

If no `user_id` is provided, the server generates one: `u-{timestamp}-{random}`.

## Authorization (Scopes)

Every CLASP operation is checked against the authenticated user's scope list. Scopes are granted at token issuance and follow the format `action:pattern`.

### Scope Enforcement Flow

```
Client sends SET/PUBLISH/SUBSCRIBE
        │
        v
  CLASP Router receives message
        │
        v
  Extract operation type:
    SET/PUBLISH -> requires write scope
    SUBSCRIBE   -> requires read scope
        │
        v
  Match address against scope patterns
  (glob matching: * = single segment, ** = recursive)
        │
        ├── Match found -> Allow operation
        └── No match -> Reject with ERROR
```

### Security-Critical Scope Restrictions

| Path | Scope | Rationale |
|------|-------|-----------|
| `crypto/pubkey/{userId}` | Write restricted to own userId | Prevents MITM: users can only publish their own ECDH public key |
| `crypto/proof/{userId}` | Write restricted to own userId | Prevents proof forgery: users can only publish their own password proof |
| `presence/{userId}` | Write restricted to own userId | Prevents presence spoofing |
| `typing/{userId}` | Write restricted to own userId | Prevents typing indicator spoofing |
| `user/{userId}/**` | Write restricted to own userId | Prevents profile impersonation |

### Known Limitations (Deferred to Phase 2)

- `read:/chat/**` grants global read access (per-room read scoping requires server-side room membership tracking)
- Admin/ban/meta paths use client-side role enforcement (server-side role validation requires room membership tracking)

## E2E Encryption

### Cryptographic Primitives

| Primitive | Algorithm | Key Size | Purpose |
|-----------|-----------|----------|---------|
| Message encryption | AES-256-GCM | 256-bit | Encrypt/decrypt chat messages |
| Key exchange | ECDH P-256 | 256-bit | Establish shared secret between peers |
| Key derivation | HKDF-SHA256 | 256-bit | Derive AES key from ECDH shared secret |
| Password hashing | PBKDF2-SHA256 | 256-bit | Hash room/namespace passwords (client-side) |
| IV generation | `crypto.getRandomValues` | 96-bit | Random IV per encryption operation |

All cryptographic operations use the Web Crypto API (`crypto.subtle`), which provides:
- Hardware-accelerated implementations where available
- Non-extractable private keys (ECDH private keys cannot be exported from Web Crypto)
- Constant-time comparison for authentication tags (AES-GCM)

### Key Lifecycle

```
1. Room Created with encryption=true
   │
   v
2. Creator generates AES-256-GCM room key
   ├── Stored in useCrypto's in-memory Map (roomKeys)
   └── Exported to JWK, persisted to IndexedDB
   │
   v
3. Creator publishes ECDH public key to CLASP state
   └── /chat/room/{roomId}/crypto/pubkey/{creatorId}
   │
   v
4. New member joins, doesn't have room key
   ├── Subscribes to key exchange: /chat/room/{roomId}/crypto/keyex/{userId}
   └── Publishes own ECDH public key: /chat/room/{roomId}/crypto/pubkey/{userId}
   │
   v
5. Existing key holder sees new public key (subscription fires)
   ├── Derives shared secret: ECDH + HKDF-SHA256
   ├── Encrypts room key with shared secret (AES-GCM)
   └── Emits encrypted key to: /chat/room/{roomId}/crypto/keyex/{newMemberId}
   │
   v
6. New member receives encrypted key
   ├── Derives same shared secret: ECDH + HKDF-SHA256
   ├── Decrypts room key
   ├── Stores in-memory and IndexedDB
   └── Can now encrypt/decrypt messages
```

### HKDF Key Derivation

The ECDH shared secret is not used directly as an AES key. Instead, it passes through HKDF-SHA256 for proper key derivation:

```
ECDH deriveBits (256-bit raw shared secret)
        │
        v
  Import as HKDF key material
        │
        v
  HKDF-SHA256(
    key:  raw ECDH bits,
    salt: 32 zero bytes,
    info: "clasp-chat-keyex-v1"    // domain separation
  )
        │
        v
  AES-256-GCM key (for encrypting the room key transfer)
```

### Key Rotation

When a user is banned from an encrypted room:

1. Admin calls `banUser()` in `useAdmin`
2. `removePeerKey(roomId, bannedUserId)` removes the banned user's cached ECDH public key
3. `rotateRoomKey(roomId)` generates a new AES-256-GCM room key
4. New key is persisted to IndexedDB
5. New ECDH public key is published (triggers re-exchange)
6. New key is proactively distributed to all cached peers (excluding the banned user)

The banned user retains the old key and can decrypt messages sent before the rotation, but cannot decrypt messages encrypted with the new key.

### Password-Protected Room Key Gating

For rooms with a password, the key exchange adds a proof verification step:

```
Joining user                                Key holder
     │                                           │
     │  1. Hash(password, room salt)              │
     │  2. Publish proof:                         │
     │     /chat/room/{rid}/crypto/proof/{uid}    │
     │     { hash, timestamp }                    │
     │                                            │
     │  3. Publish ECDH pubkey                    │
     │     (triggers key exchange)                │
     │                                            │
     │                                  4. See new pubkey
     │                                  5. Check passwordRooms map
     │                                  6. Subscribe to proof path
     │                                  7. Compare proof.hash === expectedHash
     │                                     ├── Match: proceed with key exchange
     │                                     └── No match / timeout (2s): skip
     │                                            │
     │<──────── Encrypted room key ───────────────│
```

### Message Encryption Format

Encrypted messages are emitted with this structure:

```json
{
  "from": "Alice",
  "fromId": "session-abc",
  "msgId": "1708123456789-a1b2c3",
  "text": "<base64 AES-GCM ciphertext>",
  "iv": "<base64 12-byte IV>",
  "encrypted": true,
  "timestamp": 1708123456789,
  "avatarColor": "#457b9d",
  "type": "text"
}
```

The `encrypted: true` flag tells receiving clients to decrypt before display. If an image is attached, it is separately encrypted in `encryptedImage`/`imageIv` fields.

### Decryption Error Handling

AES-GCM provides authenticated encryption. If the authentication tag fails (indicating tampering or wrong key):
- `OperationError` is caught and logged with a tampering warning
- The message displays as `[encrypted message - key unavailable]`
- Distinct from "no key" (returns null immediately) -- both cases show the placeholder

### Local Key Storage

Room keys are persisted in IndexedDB (`clasp-chat` database, `crypto-keys` object store) as JWK objects. Keys are stored unencrypted.

**Known limitation**: Device seizure exposes all room keys. Local key encryption (derived from user password) is a Phase 3 remediation item.

## CORS Configuration

The auth HTTP server supports configurable CORS:

- **With `--cors-origin`**: Restricts `Access-Control-Allow-Origin` to the specified origins (comma-separated). Only `POST` and `OPTIONS` methods are allowed.
- **Without `--cors-origin`**: Falls back to permissive CORS (for development).

Production deployments should always set `--cors-origin` to the chat frontend's domain.

## Threat Model

### What the system protects against

| Threat | Protection |
|--------|-----------|
| Passive network eavesdropper | TLS (Caddy) + E2E encryption |
| Password brute force | Argon2id server-side, rate limiting on login |
| Identity impersonation via scopes | userId-restricted write paths for presence, typing, crypto |
| MITM key injection | Crypto pubkey paths restricted to own userId |
| Password proof bypass | Hash comparison against room's expected hash |
| Mass account creation | Registration rate limiting per IP |
| Path traversal in namespaces | `sanitizeNsPath()` rejects `..`, `*`, `**`, non-alphanumeric |
| User ID format injection | `is_valid_user_id()` validates alphanumeric + hyphens/underscores |
| Cross-origin token theft | Configurable CORS with explicit origin allowlist |

### Known limitations

| Limitation | Description | Remediation Phase |
|------------|-------------|-------------------|
| Global read access | All users can read all CLASP state including room metadata | Phase 2 |
| Client-side admin enforcement | Room admin/ban/meta roles checked in JS, not on relay | Phase 2 |
| No message signatures | Messages can be forged by any room member | Phase 2 |
| No forward secrecy | Single ECDH key pair per session, static room keys | Phase 3 |
| Unencrypted local keys | IndexedDB stores room key JWKs in plaintext | Phase 3 |
| Plaintext state snapshot | Relay writes all state to disk as JSON | Phase 3 |
| No key verification UI | No safety numbers or key fingerprints for TOFU | Phase 2 |

## Security Audit History

A comprehensive security audit was performed on 2026-02-18 covering crypto, auth, access control, namespaces, transport, and storage. The following findings were remediated:

| ID | Finding | Severity | Fix |
|----|---------|----------|-----|
| C1 (partial) | Relay can MITM key exchange | Critical | Restricted crypto pubkey writes to own userId |
| C3 | Client-supplied user_id enables identity hijacking | Critical | Reject user_ids already in users table; validate format |
| C4 | Password proof doesn't verify hash | Critical | Compare proof.hash against expected room passwordHash |
| H2 | CORS permissive on auth | High | Configurable `--cors-origin` CLI arg |
| H3 | ECDH derives directly to AES without KDF | High | Added HKDF-SHA256 with domain separation |
| H7 | No login brute-force protection | High | Per-IP + per-username rate limiting |
| M2 | user_id with invalid characters | Medium | `is_valid_user_id()` validation |
| M5 | PBKDF2 iterations too low | Medium | Increased from 100k to 600k |
| M6 | No registration rate limiting | Medium | Per-IP rate limiting on register/guest |
| M7 | ECDH private key marked extractable | Medium | Set `extractable: false` on import |
| L4 | Silent decryption failure masks tampering | Low | Log AES-GCM OperationError with tampering warning |
| NEW-3 | Subscription leak in proof timeout | Bug | Added `settled` flag pattern for cleanup |
