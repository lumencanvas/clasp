//! PAT — Pattern Matcher Attack Tests
//!
//! Validates that glob matching and pattern subset logic cannot be
//! bypassed to widen a token's effective scope.

use clasp_caps::token::pattern_is_subset;
use clasp_core::address::glob_match;

// ── PAT-01: Glob match bypass ─────────────────────────────────────────
/// Verify `*` matches one segment only, `**` matches multi-segment prefix,
/// and exact patterns don't match deeper paths.
#[test]
fn test_pat_01_glob_match_bypass() {
    // `*` must NOT match across segments
    assert!(glob_match("/lights/*", "/lights/room1"));
    assert!(
        !glob_match("/lights/*", "/lights/room1/brightness"),
        "* must not match across segments"
    );

    // `**` matches any depth beneath the prefix
    assert!(glob_match("/lights/**", "/lights/room1"));
    assert!(glob_match("/lights/**", "/lights/room1/brightness"));
    assert!(glob_match("/lights/**", "/lights/a/b/c/d"));

    // `**` must NOT match outside its prefix
    assert!(!glob_match("/lights/**", "/audio/channel1"));

    // Exact patterns must not match deeper paths
    assert!(glob_match("/lights/room1", "/lights/room1"));
    assert!(!glob_match("/lights/room1", "/lights/room1/brightness"));
}

// ── PAT-02: Wildcard in address ────────────────────────────────────────
/// Security-relevant scenario: a malicious SET to address `/lights/*`
/// (literal asterisk). Subscribers with pattern `/lights/*` must receive it.
/// But an exact address pattern must NOT match a wildcard address.
#[test]
fn test_pat_02_wildcard_in_address() {
    // A literal `*` in the address is caught by the `*` wildcard in the pattern
    assert!(
        glob_match("/lights/*", "/lights/*"),
        "pattern /lights/* must match address /lights/* (literal asterisk is a valid segment)"
    );

    // Pattern `*` also matches normal segments
    assert!(
        glob_match("/lights/*", "/lights/room1"),
        "pattern /lights/* must match /lights/room1"
    );

    // Critical: an exact address pattern does NOT match a wildcard address
    assert!(
        !glob_match("/lights/room1", "/lights/*"),
        "exact pattern /lights/room1 must NOT match address /lights/* — \
         patterns are directional (pattern matches address, not reverse)"
    );

    // A subscriber to /lights/** gets literal-asterisk addresses too
    assert!(
        glob_match("/lights/**", "/lights/*"),
        "/lights/** must match /lights/* (literal asterisk)"
    );
    assert!(
        glob_match("/lights/**", "/lights/*/brightness"),
        "/lights/** must match /lights/*/brightness"
    );
}

// ── PAT-03: Empty and root patterns ───────────────────────────────────
/// Security-relevant edge cases for CLASP scope decisions: can empty
/// strings sneak through `/**`? Is empty-string a subset of `/**`?
/// Documents the exact behavior at each boundary.
#[test]
fn test_pat_03_empty_and_root_patterns() {
    // Can empty string sneak through the widest pattern?
    let empty_through_globstar = glob_match("/**", "");
    // Document: empty address does NOT match /** (requires leading /)
    assert!(
        !empty_through_globstar,
        "empty address must NOT sneak through /** — \
         addresses must be rooted"
    );

    // Is empty-string pattern a subset of /**?
    let empty_subset = pattern_is_subset("", "/**");
    // Document the actual behavior (empty is trivially a subset — matches nothing)
    assert!(
        empty_subset,
        "empty pattern is a subset of /** (it matches nothing, \
         which is trivially contained in everything)"
    );

    // Is "/" a subset of "/**"?
    assert!(
        pattern_is_subset("/", "/**"),
        "root / must be a subset of /**"
    );

    // Security check: `/**` must NOT be a subset of `/`
    assert!(
        !pattern_is_subset("/**", "/"),
        "/** must NOT be a subset of / (/** is wider)"
    );

    // `/**` matches any rooted address — scope boundary test
    assert!(glob_match("/**", "/anything"));
    assert!(glob_match("/**", "/a/b/c/d/e"));
    assert!(!glob_match("/**", "no-leading-slash"));
}

// ── PAT-04: pattern_is_subset edge cases ──────────────────────────────
/// `/**` is NOT a subset of `/a/*`, `../` traversal is treated as a
/// literal segment, and edge cases around empty children.
#[test]
fn test_pat_04_pattern_is_subset_edge_cases() {
    // `/**` is the widest pattern — it is NOT a subset of anything narrower
    assert!(
        !pattern_is_subset("/**", "/a/*"),
        "/** is wider than /a/* and must not be a subset"
    );
    assert!(
        !pattern_is_subset("/**", "/a/**"),
        "/** is wider than /a/**"
    );

    // But it IS a subset of itself
    assert!(pattern_is_subset("/**", "/**"));

    // `../` traversal is treated as literal segments (no path normalization)
    assert!(
        !pattern_is_subset("/../secret", "/a/**"),
        "path traversal must not escape the parent pattern"
    );
    assert!(pattern_is_subset("/../secret", "/**"));

    // A child that has wildcard where parent has literal is NOT a subset
    assert!(!pattern_is_subset("/a/*", "/a/b"));

    // Subset relationship with varying depths
    assert!(pattern_is_subset("/a/b/c", "/a/**"));
    assert!(!pattern_is_subset("/a/**", "/a/b/c"));

    // Empty child is a subset of everything (trivially matches nothing)
    assert!(pattern_is_subset("", ""));
}

// ── PAT-05: Subscription scope escape via TokenInfo ───────────────────
/// Validate token scopes via has_scope(), ensuring wider patterns are
/// rejected when the token holds a narrow scope.
#[test]
fn test_pat_05_subscription_scope_escape() {
    use clasp_core::security::{Action, Scope, TokenInfo};

    let scopes = vec![Scope::new(Action::Read, "/lights/*").unwrap()];
    let info = TokenInfo::new("test-token".to_string(), scopes);

    // Should allow reading a single segment under /lights/
    assert!(info.has_scope(Action::Read, "/lights/room1"));

    // Should NOT allow reading deeper (multi-segment)
    assert!(
        !info.has_scope(Action::Read, "/lights/room1/brightness"),
        "read:/lights/* must not allow /lights/room1/brightness"
    );

    // Should NOT allow writing at all
    assert!(!info.has_scope(Action::Write, "/lights/room1"));

    // Should NOT allow reading outside /lights/
    assert!(!info.has_scope(Action::Read, "/audio/channel1"));

    // Admin scope should allow everything
    let admin_scopes = vec![Scope::new(Action::Admin, "/**").unwrap()];
    let admin_info = TokenInfo::new("admin-token".to_string(), admin_scopes);
    assert!(admin_info.has_scope(Action::Read, "/anything/deep/path"));
    assert!(admin_info.has_scope(Action::Write, "/anything"));
    assert!(admin_info.has_scope(Action::Admin, "/anything"));
}
