//! JNL — Journal Attack Tests
//!
//! Validates journal integrity, access control boundaries, storage
//! exhaustion handling, snapshot corruption resilience, and sequence
//! number auto-assignment.

use clasp_core::{SignalType, Value};
use clasp_journal::{Journal, JournalEntry, MemoryJournal, ParamSnapshot};

// ── JNL-01: Journal tampering (SQLite) ─────────────────────────────────
/// FINDING: Journal has no integrity verification. Write a known value,
/// tamper SQLite directly, verify the tampered value is returned silently.
#[cfg(feature = "sqlite")]
#[tokio::test]
async fn test_jnl_01_journal_tampering() {
    use clasp_journal::SqliteJournal;

    let dir = tempfile::tempdir().unwrap();
    let db_path = dir.path().join("test.db");
    let journal = SqliteJournal::new(db_path.to_str().unwrap()).unwrap();

    // Write a known value: Float(42.0)
    let entry = JournalEntry::from_set(
        "/lights/room1/brightness".to_string(),
        Value::Float(42.0),
        1,
        "session1".to_string(),
        1000000,
    );
    let seq = journal.append(entry).await.unwrap();
    assert!(seq > 0);

    // Verify the original value is stored correctly
    let before = journal.query("/**", None, None, None, &[]).await.unwrap();
    assert_eq!(before.len(), 1);
    assert_eq!(
        before[0].value,
        Value::Float(42.0),
        "original value must be stored correctly"
    );

    // Tamper: change 42.0 to 999.0 directly in SQLite
    {
        let conn = rusqlite::Connection::open(db_path.to_str().unwrap()).unwrap();
        conn.execute(
            "UPDATE journal_entries SET value_json = '999.0' WHERE seq = ?1",
            rusqlite::params![seq as i64],
        )
        .unwrap();
    }

    // Query the tampered entry — journal returns tampered data as-is
    let after = journal.query("/**", None, None, None, &[]).await.unwrap();
    assert_eq!(after.len(), 1);
    assert_eq!(
        after[0].value,
        Value::Float(999.0),
        "FINDING: Journal has no integrity verification. Tampered values \
         are returned silently. The original 42.0 was replaced with 999.0 \
         and the journal returned it without error."
    );
    // The tampered value is NOT the original
    assert_ne!(
        after[0].value,
        Value::Float(42.0),
        "tampered value must differ from original"
    );
}

// ── JNL-02: Replay access control ──────────────────────────────────────
/// Append entries to various addresses, query with pattern filter,
/// verify only matching entries are returned.
#[tokio::test]
async fn test_jnl_02_replay_access_control() {
    let journal = MemoryJournal::new(1000);

    // Append entries to different addresses
    let addresses = [
        "/lights/room1/brightness",
        "/lights/room2/brightness",
        "/audio/mixer/volume",
        "/audio/eq/bass",
        "/admin/config",
    ];

    for (i, addr) in addresses.iter().enumerate() {
        let entry = JournalEntry::from_set(
            addr.to_string(),
            Value::Float(i as f64 * 0.1),
            i as u64 + 1,
            "session1".to_string(),
            (i as u64 + 1) * 1000,
        );
        journal.append(entry).await.unwrap();
    }

    // Query /lights/** — should only return light entries
    let lights = journal
        .query("/lights/**", None, None, None, &[])
        .await
        .unwrap();
    assert_eq!(lights.len(), 2, "should get 2 entries for /lights/**");

    // Query /audio/** — should only return audio entries
    let audio = journal
        .query("/audio/**", None, None, None, &[])
        .await
        .unwrap();
    assert_eq!(audio.len(), 2, "should get 2 entries for /audio/**");

    // Query /admin/** — single entry
    let admin = journal
        .query("/admin/**", None, None, None, &[])
        .await
        .unwrap();
    assert_eq!(admin.len(), 1);

    // Query with non-matching pattern — empty
    let none = journal
        .query("/nonexistent/**", None, None, None, &[])
        .await
        .unwrap();
    assert!(none.is_empty());

    // NOTE: Scope enforcement is the router's responsibility.
    // The journal just filters by glob pattern on the address.
}

// ── JNL-03: Storage exhaustion ─────────────────────────────────────────
/// MemoryJournal(100): 1000 appends -> len=100 (eviction).
#[tokio::test]
async fn test_jnl_03_storage_exhaustion() {
    let journal = MemoryJournal::new(100);

    // Append 1000 entries
    for i in 0..1000 {
        let entry = JournalEntry::from_set(
            format!("/data/{}", i),
            Value::Int(i),
            i as u64 + 1,
            "writer".to_string(),
            (i as u64 + 1) * 1000,
        );
        journal.append(entry).await.unwrap();
    }

    // Should have exactly 100 entries (oldest evicted)
    let len = journal.len().await.unwrap();
    assert_eq!(len, 100, "MemoryJournal should evict oldest entries");

    // The remaining entries should be the last 100 (901-1000)
    let all = journal.query("/**", None, None, None, &[]).await.unwrap();
    assert_eq!(all.len(), 100);

    // First remaining entry should have a high address number
    let first_addr = &all[0].address;
    assert!(
        first_addr.starts_with("/data/9"),
        "first remaining entry should be from the 900s, got: {}",
        first_addr
    );

    // NOTE: SqliteJournal has NO auto-eviction limit.
    // In production, compaction or external size management is required.
}

// ── JNL-04: Snapshot corruption (SQLite) ───────────────────────────────
/// Corrupt snapshot JSON to invalid syntax → load_snapshot() must return Err.
/// Corrupt to valid JSON but wrong schema → must also return Err.
/// The implementation uses serde_json::from_str::<Vec<ParamSnapshot>>()
/// which should fail on both.
#[cfg(feature = "sqlite")]
#[tokio::test]
async fn test_jnl_04_snapshot_corruption() {
    use clasp_journal::SqliteJournal;

    let dir = tempfile::tempdir().unwrap();
    let db_path = dir.path().join("test.db");
    let journal = SqliteJournal::new(db_path.to_str().unwrap()).unwrap();

    // Save a valid snapshot
    let snapshots = vec![ParamSnapshot {
        address: "/test/a".to_string(),
        value: Value::Float(1.0),
        revision: 5,
        writer: "s1".to_string(),
        timestamp: 1000,
    }];
    journal.snapshot(&snapshots).await.unwrap();

    // Verify it loads correctly first
    let loaded = journal.load_snapshot().await.unwrap();
    assert!(loaded.is_some(), "valid snapshot must load");
    let data = loaded.unwrap();
    assert_eq!(data.len(), 1);
    assert_eq!(data[0].address, "/test/a");

    // Corruption vector 1: Invalid JSON syntax
    {
        let conn = rusqlite::Connection::open(db_path.to_str().unwrap()).unwrap();
        conn.execute(
            "UPDATE snapshots SET data_json = 'NOT VALID JSON{{{'",
            [],
        )
        .unwrap();
    }

    let result = journal.load_snapshot().await;
    assert!(
        result.is_err(),
        "invalid JSON syntax must cause load_snapshot() to return Err, got: {:?}",
        result
    );

    // Corruption vector 2: Valid JSON but wrong schema
    // Re-save valid snapshot first, then corrupt
    journal.snapshot(&snapshots).await.unwrap();
    {
        let conn = rusqlite::Connection::open(db_path.to_str().unwrap()).unwrap();
        conn.execute(
            "UPDATE snapshots SET data_json = '[123, 456]'",
            [],
        )
        .unwrap();
    }

    let result2 = journal.load_snapshot().await;
    assert!(
        result2.is_err(),
        "valid JSON with wrong schema must cause load_snapshot() to return Err, got: {:?}",
        result2
    );
}

// ── JNL-05: Sequence number manipulation ───────────────────────────────
/// Append entries with pre-set seq values. Verify journal auto-assigns
/// sequential seq values (caller values overridden).
#[tokio::test]
async fn test_jnl_05_sequence_number_manipulation() {
    let journal = MemoryJournal::new(100);

    // Create entries with attacker-chosen seq numbers
    let mut entry1 = JournalEntry::from_set(
        "/test/a".to_string(),
        Value::Float(1.0),
        1,
        "session1".to_string(),
        1000,
    );
    entry1.seq = 999; // Attacker tries to set seq

    let mut entry2 = JournalEntry::from_set(
        "/test/b".to_string(),
        Value::Float(2.0),
        2,
        "session1".to_string(),
        2000,
    );
    entry2.seq = 1; // Attacker tries to set seq to 1

    let mut entry3 = JournalEntry::from_set(
        "/test/c".to_string(),
        Value::Float(3.0),
        3,
        "session1".to_string(),
        3000,
    );
    entry3.seq = 0; // Attacker tries to set seq to 0

    let seq1 = journal.append(entry1).await.unwrap();
    let seq2 = journal.append(entry2).await.unwrap();
    let seq3 = journal.append(entry3).await.unwrap();

    // Journal must auto-assign sequential seq numbers
    assert_eq!(seq1, 1, "first entry should get seq 1");
    assert_eq!(seq2, 2, "second entry should get seq 2");
    assert_eq!(seq3, 3, "third entry should get seq 3");

    // Verify stored entries have auto-assigned seqs
    let all = journal.query("/**", None, None, None, &[]).await.unwrap();
    assert_eq!(all[0].seq, 1);
    assert_eq!(all[1].seq, 2);
    assert_eq!(all[2].seq, 3);

    // latest_seq should reflect the auto-assigned value
    let latest = journal.latest_seq().await.unwrap();
    assert_eq!(latest, 3);
}
