//! ENT — Entity Token Attack Tests
//!
//! Validates entity token signature verification, status lifecycle
//! enforcement, cross-store isolation, and malformed input handling.

use clasp_core::security::{TokenValidator, ValidationResult};
use clasp_registry::{
    EntityKeypair, EntityStatus, EntityStore, EntityType, EntityValidator, MemoryEntityStore,
    generate_token, parse_token,
};
use std::sync::Arc;

// ── ENT-01: Signature bypass ───────────────────────────────────────────
/// Token claims entity A but is signed by KeyB -> Invalid("signature")
#[tokio::test(flavor = "multi_thread")]
async fn test_ent_01_signature_bypass() {
    let store: Arc<dyn EntityStore> = Arc::new(MemoryEntityStore::new());
    let keypair_a = EntityKeypair::generate().unwrap();
    let entity_a = keypair_a.to_entity(EntityType::Device, "device-a".to_string());
    store.create(&entity_a).await.unwrap();

    let keypair_b = EntityKeypair::generate().unwrap();

    // Craft a token that claims entity_a's ID but is signed by keypair_b
    let token = {
        use base64::engine::general_purpose::URL_SAFE_NO_PAD;
        use base64::Engine;
        use ed25519_dalek::Signer;

        let timestamp = std::time::SystemTime::now()
            .duration_since(std::time::UNIX_EPOCH)
            .unwrap()
            .as_secs();
        let entity_id = keypair_a.entity_id.as_str().to_string();
        let mut message = entity_id.as_bytes().to_vec();
        message.extend_from_slice(&timestamp.to_be_bytes());

        let signature = keypair_b.signing_key.sign(&message);

        let payload = clasp_registry::token::EntityTokenPayload {
            entity_id,
            timestamp,
            signature: signature.to_bytes().to_vec(),
        };
        let encoded = rmp_serde::to_vec(&payload).unwrap();
        format!("ent_{}", URL_SAFE_NO_PAD.encode(&encoded))
    };

    let validator = EntityValidator::new(store);
    match validator.validate(&token) {
        ValidationResult::Invalid(msg) => {
            assert!(
                msg.contains("signature"),
                "expected signature error, got: {}",
                msg
            );
        }
        other => panic!("expected Invalid(signature), got: {:?}", other),
    }
}

// ── ENT-02: Status race condition ──────────────────────────────────────
/// Mint token, suspend entity, validate -> Invalid("suspended")
#[tokio::test(flavor = "multi_thread")]
async fn test_ent_02_status_race_condition() {
    let store: Arc<dyn EntityStore> = Arc::new(MemoryEntityStore::new());
    let keypair = EntityKeypair::generate().unwrap();
    let entity = keypair.to_entity(EntityType::Device, "device".to_string());
    store.create(&entity).await.unwrap();

    // Generate token while entity is active
    let token = generate_token(&keypair).unwrap();

    let validator = EntityValidator::new(store.clone());

    // Validate while active — should succeed
    assert!(
        matches!(validator.validate(&token), ValidationResult::Valid(_)),
        "token should be valid while entity is active"
    );

    // Suspend entity
    store
        .update_status(&keypair.entity_id, EntityStatus::Suspended)
        .await
        .unwrap();

    // Validate after suspension — should fail
    match validator.validate(&token) {
        ValidationResult::Invalid(msg) => {
            assert!(
                msg.contains("suspended") || msg.contains("Suspended"),
                "expected suspended error, got: {}",
                msg
            );
        }
        other => panic!("expected Invalid(suspended), got: {:?}", other),
    }
}

// ── ENT-03: Suspended entity reactivation ──────────────────────────────
/// Tests ONLY the reactivation path (suspension is covered by ENT-02).
/// Reactivate a suspended entity, assert token works again with correct identity.
#[tokio::test(flavor = "multi_thread")]
async fn test_ent_03_suspended_entity_reactivation() {
    let store: Arc<dyn EntityStore> = Arc::new(MemoryEntityStore::new());
    let keypair = EntityKeypair::generate().unwrap();
    let entity = keypair.to_entity(EntityType::Device, "device".to_string());
    store.create(&entity).await.unwrap();

    let token = generate_token(&keypair).unwrap();
    let validator = EntityValidator::new(store.clone());

    // Start suspended
    store
        .update_status(&keypair.entity_id, EntityStatus::Suspended)
        .await
        .unwrap();

    // Reactivate
    store
        .update_status(&keypair.entity_id, EntityStatus::Active)
        .await
        .unwrap();

    // Token must work after reactivation, returning correct identity
    match validator.validate(&token) {
        ValidationResult::Valid(info) => {
            assert_eq!(
                info.subject.as_deref(),
                Some(keypair.entity_id.as_str()),
                "reactivated entity token must return correct entity ID in subject"
            );
        }
        other => panic!("expected Valid after reactivation, got: {:?}", other),
    }
}

// ── ENT-04: Nonexistent entity ─────────────────────────────────────────
/// Token for unregistered keypair -> Invalid("not found")
#[tokio::test(flavor = "multi_thread")]
async fn test_ent_04_nonexistent_entity() {
    let store = Arc::new(MemoryEntityStore::new());
    let validator = EntityValidator::new(store);

    let keypair = EntityKeypair::generate().unwrap();
    let token = generate_token(&keypair).unwrap();

    match validator.validate(&token) {
        ValidationResult::Invalid(msg) => {
            assert!(
                msg.contains("not found"),
                "expected 'not found', got: {}",
                msg
            );
        }
        other => panic!("expected Invalid(not found), got: {:?}", other),
    }
}

// ── ENT-05: Malformed token ────────────────────────────────────────────
/// Random bytes, truncated, wrong key length, truncated signature.
#[tokio::test(flavor = "multi_thread")]
async fn test_ent_05_malformed_token() {
    use base64::Engine;

    let store = Arc::new(MemoryEntityStore::new());
    let validator = EntityValidator::new(store);

    // Random bytes
    let random = base64::engine::general_purpose::URL_SAFE_NO_PAD
        .encode(&[0xDE, 0xAD, 0xBE, 0xEF]);
    assert!(matches!(
        validator.validate(&format!("ent_{}", random)),
        ValidationResult::Invalid(_)
    ));

    // Truncated payload
    let truncated = base64::engine::general_purpose::URL_SAFE_NO_PAD.encode(&[0x92, 0x01]);
    assert!(matches!(
        validator.validate(&format!("ent_{}", truncated)),
        ValidationResult::Invalid(_)
    ));

    // Bad base64
    assert!(matches!(
        validator.validate("ent_!!!not-valid!!!"),
        ValidationResult::Invalid(_)
    ));

    // Wrong prefix
    assert!(matches!(
        validator.validate("cpsk_something"),
        ValidationResult::NotMyToken
    ));

    // Empty after prefix
    assert!(matches!(
        validator.validate("ent_"),
        ValidationResult::Invalid(_)
    ));

    // parse_token with wrong key length
    let result = parse_token("not_a_token");
    assert!(result.is_err());
}

// ── ENT-06: Token timestamp freshness ────────────────────────────────
/// Validator with max_token_age rejects old tokens. Validates that the
/// timestamp checking mechanism works correctly.
#[tokio::test(flavor = "multi_thread")]
async fn test_ent_06_token_timestamp_freshness() {
    let store: Arc<dyn EntityStore> = Arc::new(MemoryEntityStore::new());
    let keypair = EntityKeypair::generate().unwrap();
    let entity = keypair.to_entity(EntityType::Device, "device".to_string());
    store.create(&entity).await.unwrap();

    // Validator with very short max_token_age (1 second)
    let strict_validator = EntityValidator::new(store.clone())
        .with_max_token_age(1);

    // Generate token — should be valid immediately
    let token = generate_token(&keypair).unwrap();
    assert!(
        matches!(strict_validator.validate(&token), ValidationResult::Valid(_)),
        "fresh token should be valid within max_token_age"
    );

    // Wait for token to age past the limit
    tokio::time::sleep(std::time::Duration::from_secs(2)).await;

    // Aged token should now be rejected
    match strict_validator.validate(&token) {
        ValidationResult::Expired => {}
        other => panic!("expected Expired for aged token, got: {:?}", other),
    }

    // Validator with no age limit (default) still accepts the same token
    let permissive_validator = EntityValidator::new(store.clone());
    assert!(
        matches!(permissive_validator.validate(&token), ValidationResult::Valid(_)),
        "validator with no max_token_age should accept old tokens"
    );

    // Generate a new token — should be valid even with strict validator
    let fresh_token = generate_token(&keypair).unwrap();
    assert!(
        matches!(strict_validator.validate(&fresh_token), ValidationResult::Valid(_)),
        "freshly generated token should be valid"
    );
}

// ── ENT-07: Cross-store attack ─────────────────────────────────────────
/// Entity registered in store A, validated against store B -> "not found"
#[tokio::test(flavor = "multi_thread")]
async fn test_ent_07_cross_store_attack() {
    let store_a: Arc<dyn EntityStore> = Arc::new(MemoryEntityStore::new());
    let store_b: Arc<dyn EntityStore> = Arc::new(MemoryEntityStore::new());

    let keypair = EntityKeypair::generate().unwrap();
    let entity = keypair.to_entity(EntityType::Service, "service".to_string());

    // Register in store A only
    store_a.create(&entity).await.unwrap();

    let token = generate_token(&keypair).unwrap();

    // Validate against store A: should succeed
    let validator_a = EntityValidator::new(store_a);
    assert!(matches!(
        validator_a.validate(&token),
        ValidationResult::Valid(_)
    ));

    // Validate against store B: should fail (entity not found)
    let validator_b = EntityValidator::new(store_b);
    match validator_b.validate(&token) {
        ValidationResult::Invalid(msg) => {
            assert!(
                msg.contains("not found"),
                "expected 'not found', got: {}",
                msg
            );
        }
        other => panic!("expected Invalid(not found) for store B, got: {:?}", other),
    }
}
