//! FED — Federation Attack Tests
//!
//! Validates namespace hijacking prevention, pattern count limits,
//! revision vector limits, loop injection, scope enforcement, and
//! state poisoning resistance.

#![cfg(all(feature = "websocket", feature = "federation"))]

use clasp_core::{
    codec, FederationOp, FederationSyncMessage, HelloMessage, Message, SetMessage, Value,
};
use clasp_router::{Router, RouterConfig};
use clasp_transport::{Transport, TransportEvent, TransportReceiver, TransportSender, WebSocketTransport};
use std::collections::HashMap;
use std::time::Duration;
use tokio::net::TcpListener;
use tokio::time::timeout;

async fn find_available_port() -> u16 {
    let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
    listener.local_addr().unwrap().port()
}

async fn recv_msg<R: TransportReceiver>(receiver: &mut R) -> Option<Message> {
    timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = receiver.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    return msg;
                }
            }
        }
    })
    .await
    .ok()
}

async fn federation_handshake<S: TransportSender, R: TransportReceiver>(
    sender: &S,
    receiver: &mut R,
    name: &str,
) {
    let hello = Message::Hello(HelloMessage {
        version: 2,
        name: name.to_string(),
        features: vec!["param".to_string(), "federation".to_string()],
        capabilities: None,
        token: None,
    });
    sender.send(codec::encode(&hello).unwrap()).await.unwrap();

    let mut got_welcome = false;
    let mut got_snapshot = false;
    let deadline = timeout(Duration::from_secs(3), async {
        while !got_welcome || !got_snapshot {
            if let Some(TransportEvent::Data(data)) = receiver.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    match msg {
                        Message::Welcome(_) => got_welcome = true,
                        Message::Snapshot(_) => got_snapshot = true,
                        _ => {}
                    }
                }
            }
        }
    })
    .await;
    assert!(deadline.is_ok(), "federation handshake timed out");
}

async fn normal_handshake<S: TransportSender, R: TransportReceiver>(
    sender: &S,
    receiver: &mut R,
    name: &str,
) {
    let hello = Message::Hello(HelloMessage {
        version: 2,
        name: name.to_string(),
        features: vec!["param".to_string()],
        capabilities: None,
        token: None,
    });
    sender.send(codec::encode(&hello).unwrap()).await.unwrap();

    let mut got_welcome = false;
    let mut got_snapshot = false;
    let deadline = timeout(Duration::from_secs(3), async {
        while !got_welcome || !got_snapshot {
            if let Some(TransportEvent::Data(data)) = receiver.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    match msg {
                        Message::Welcome(_) => got_welcome = true,
                        Message::Snapshot(_) => got_snapshot = true,
                        _ => {}
                    }
                }
            }
        }
    })
    .await;
    assert!(deadline.is_ok(), "normal handshake timed out");
}

async fn setup_router() -> (String, tokio::task::JoinHandle<()>) {
    let port = find_available_port().await;
    let addr = format!("127.0.0.1:{}", port);
    let router = Router::new(RouterConfig {
        features: vec!["param".to_string(), "federation".to_string()],
        ..Default::default()
    });

    let handle = {
        let addr = addr.clone();
        tokio::spawn(async move {
            let _ = router.serve_websocket(&addr).await;
        })
    };

    tokio::time::sleep(Duration::from_millis(100)).await;
    (format!("ws://{}", addr), handle)
}

async fn declare_and_ack<S: TransportSender, R: TransportReceiver>(
    sender: &S,
    receiver: &mut R,
    patterns: Vec<String>,
) {
    let declare = Message::FederationSync(FederationSyncMessage {
        op: FederationOp::DeclareNamespaces,
        patterns,
        revisions: HashMap::new(),
        since_revision: None,
        origin: Some("peer".to_string()),
    });
    sender.send(codec::encode(&declare).unwrap()).await.unwrap();

    let response = recv_msg(receiver).await;
    assert!(
        response.is_some(),
        "should receive response for DeclareNamespaces"
    );
    let msg = response.unwrap();
    assert!(
        matches!(msg, Message::Ack(_)),
        "expected ACK for DeclareNamespaces, got: {:?}",
        msg
    );
}

// ── FED-01: Namespace hijacking ────────────────────────────────────────
/// FINDING: In open mode, any peer can declare /** and receive all traffic.
/// Two peers: Peer-B declares /** (hijack), Peer-A declares /site-a/**.
/// Normal client SETs /site-a/secret. Both peers receive it.
#[tokio::test]
async fn test_fed_01_namespace_hijacking() {
    let (url, handle) = setup_router().await;

    // Peer-A: legitimate owner of /site-a/**
    let (peer_a, mut peer_a_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&peer_a, &mut peer_a_rx, "Peer-A").await;
    declare_and_ack(&peer_a, &mut peer_a_rx, vec!["/site-a/**".to_string()]).await;

    // Peer-B: hijacker declares /**
    let (peer_b, mut peer_b_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&peer_b, &mut peer_b_rx, "Peer-B").await;
    declare_and_ack(&peer_b, &mut peer_b_rx, vec!["/**".to_string()]).await;

    // Normal client SETs /site-a/secret
    let (setter, mut setter_rx) = WebSocketTransport::connect(&url).await.unwrap();
    normal_handshake(&setter, &mut setter_rx, "Setter").await;

    let set = Message::Set(SetMessage {
        address: "/site-a/secret".to_string(),
        value: Value::String("classified".to_string()),
        revision: None,
        lock: false,
        unlock: false,
    });
    setter.send(codec::encode(&set).unwrap()).await.unwrap();
    let _ = recv_msg(&mut setter_rx).await; // ACK

    // Peer-B (hijacker) receives it — FINDING: hijack succeeds in open mode
    let hijack_received = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = peer_b_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/site-a/secret" {
                            return s.value.clone();
                        }
                    }
                }
            }
        }
    })
    .await;
    assert!(
        hijack_received.is_ok(),
        "FINDING: In open mode, any peer can declare /** and receive all traffic"
    );
    assert_eq!(
        hijack_received.unwrap(),
        Value::String("classified".to_string()),
        "hijacker receives the exact value"
    );

    // Peer-A (legitimate) ALSO receives it
    let legit_received = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = peer_a_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/site-a/secret" {
                            return s.value.clone();
                        }
                    }
                }
            }
        }
    })
    .await;
    assert!(
        legit_received.is_ok(),
        "legitimate owner must also receive the data"
    );

    // FINDING: In open mode, any peer can declare /** and receive all traffic.
    // Authenticated mode is required for namespace isolation.

    handle.abort();
}

// ── FED-02: Pattern count exhaustion ───────────────────────────────────
/// 1001 patterns -> Error(400, "too many")
#[tokio::test]
async fn test_fed_02_pattern_count_exhaustion() {
    let (url, handle) = setup_router().await;
    let (fed, mut fed_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&fed, &mut fed_rx, "Peer").await;

    let patterns: Vec<String> = (0..1001).map(|i| format!("/ns{}", i)).collect();

    let msg = Message::FederationSync(FederationSyncMessage {
        op: FederationOp::DeclareNamespaces,
        patterns,
        revisions: HashMap::new(),
        since_revision: None,
        origin: Some("peer".to_string()),
    });
    fed.send(codec::encode(&msg).unwrap()).await.unwrap();

    let response = recv_msg(&mut fed_rx).await;
    assert!(response.is_some());
    match response.unwrap() {
        Message::Error(err) => {
            assert_eq!(err.code, 400);
            assert!(err.message.contains("too many"));
        }
        other => panic!("expected Error(400), got: {:?}", other),
    }

    handle.abort();
}

// ── FED-03: Revision vector exhaustion ─────────────────────────────────
/// RevisionVector with 10,001 entries -> Error(400)
#[tokio::test]
async fn test_fed_03_revision_vector_exhaustion() {
    let (url, handle) = setup_router().await;
    let (fed, mut fed_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&fed, &mut fed_rx, "Peer").await;

    declare_and_ack(&fed, &mut fed_rx, vec!["/**".to_string()]).await;

    // Build 10,001 entries
    let mut revisions = HashMap::new();
    for i in 0..10_001 {
        revisions.insert(format!("/addr/{}", i), 0u64);
    }

    let msg = Message::FederationSync(FederationSyncMessage {
        op: FederationOp::RevisionVector,
        patterns: vec![],
        revisions,
        since_revision: None,
        origin: None,
    });

    // The codec may reject the oversized payload at encode time (PayloadTooLarge),
    // which is itself a valid defense. Otherwise, the router should return Error(400).
    match codec::encode(&msg) {
        Err(_) => {
            // PayloadTooLarge at codec level — oversized revision vector is
            // rejected before it even reaches the wire. This is correct behavior.
        }
        Ok(bytes) => {
            fed.send(bytes).await.unwrap();
            let response = recv_msg(&mut fed_rx).await;
            assert!(response.is_some());
            match response.unwrap() {
                Message::Error(err) => {
                    assert_eq!(err.code, 400);
                }
                other => panic!("expected Error(400), got: {:?}", other),
            }
        }
    }

    handle.abort();
}

// ── FED-04: Loop injection ─────────────────────────────────────────────
/// Peer-A declares /site-a/**, subscribes, sends SET to /site-a/data.
/// Count how many SETs to /site-a/data arrive within 500ms.
/// Exactly 1 = self-echo from subscription. >1 = loop detected.
#[tokio::test]
async fn test_fed_04_loop_injection() {
    let (url, handle) = setup_router().await;

    // Peer A declares /site-a/** (this creates a subscription)
    let (peer_a, mut peer_a_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&peer_a, &mut peer_a_rx, "Peer-A").await;
    declare_and_ack(&peer_a, &mut peer_a_rx, vec!["/site-a/**".to_string()]).await;

    // Peer A sends a SET
    let set = Message::Set(SetMessage {
        address: "/site-a/data".to_string(),
        value: Value::Float(42.0),
        revision: None,
        lock: false,
        unlock: false,
    });
    peer_a.send(codec::encode(&set).unwrap()).await.unwrap();

    // Collect ALL messages Peer-A receives for 500ms, count SETs to /site-a/data
    let mut set_count = 0u32;
    let _ = timeout(Duration::from_millis(500), async {
        loop {
            if let Some(TransportEvent::Data(data)) = peer_a_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/site-a/data" {
                            set_count += 1;
                        }
                    }
                }
            }
        }
    })
    .await;

    // Per implementation, find_subscribers does NOT include the sender,
    // so set_count should be 0 (no self-echo). If the implementation
    // includes sender, count should be exactly 1.
    assert!(
        set_count <= 1,
        "loop detected: received {} SETs to /site-a/data (expected 0 or 1). \
         If >1, the router has a federation loop.",
        set_count
    );

    // Document the exact behavior
    if set_count == 0 {
        // find_subscribers excludes sender — no self-echo
    } else {
        // find_subscribers includes sender — self-echo but no amplification
    }

    handle.abort();
}

// ── FED-05: Unauthorized sync request ──────────────────────────────────
/// Declare /site-a/**, sync /site-b/** -> Error(403, "not covered")
#[tokio::test]
async fn test_fed_05_unauthorized_sync_request() {
    let (url, handle) = setup_router().await;
    let (fed, mut fed_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&fed, &mut fed_rx, "Peer").await;

    declare_and_ack(&fed, &mut fed_rx, vec!["/site-a/**".to_string()]).await;

    // Request sync for /site-b/** which is NOT in declared namespaces
    let sync = Message::FederationSync(FederationSyncMessage {
        op: FederationOp::RequestSync,
        patterns: vec!["/site-b/**".to_string()],
        revisions: HashMap::new(),
        since_revision: None,
        origin: None,
    });
    fed.send(codec::encode(&sync).unwrap()).await.unwrap();

    let response = recv_msg(&mut fed_rx).await;
    assert!(response.is_some());
    match response.unwrap() {
        Message::Error(err) => {
            assert_eq!(err.code, 403);
            assert!(err.message.contains("not covered"));
        }
        other => panic!("expected Error(403), got: {:?}", other),
    }

    handle.abort();
}

// ── FED-06: Non-federation sync attempt ────────────────────────────────
/// Normal client sends FederationSync -> Error(403)
#[tokio::test]
async fn test_fed_06_non_federation_sync_attempt() {
    let (url, handle) = setup_router().await;
    let (client, mut client_rx) = WebSocketTransport::connect(&url).await.unwrap();
    normal_handshake(&client, &mut client_rx, "Normal Client").await;

    let fed_msg = Message::FederationSync(FederationSyncMessage {
        op: FederationOp::DeclareNamespaces,
        patterns: vec!["/sensors/**".to_string()],
        revisions: HashMap::new(),
        since_revision: None,
        origin: Some("rogue".to_string()),
    });
    client.send(codec::encode(&fed_msg).unwrap()).await.unwrap();

    let response = recv_msg(&mut client_rx).await;
    assert!(response.is_some());
    match response.unwrap() {
        Message::Error(err) => {
            assert_eq!(err.code, 403);
        }
        other => panic!("expected Error(403), got: {:?}", other),
    }

    handle.abort();
}

// ── FED-07: Pattern coverage bypass ────────────────────────────────────
/// Declare /site-a/*, sync /site-a/** -> rejected (** wider than *).
/// Declare exact path, sync globstar -> rejected.
#[tokio::test]
async fn test_fed_07_pattern_coverage_bypass() {
    let (url, handle) = setup_router().await;
    let (fed, mut fed_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&fed, &mut fed_rx, "Peer").await;

    // Declare /site-a/* (single level only)
    declare_and_ack(&fed, &mut fed_rx, vec!["/site-a/*".to_string()]).await;

    // Try to sync /site-a/** (multi-level, wider) -> should be rejected
    let sync = Message::FederationSync(FederationSyncMessage {
        op: FederationOp::RequestSync,
        patterns: vec!["/site-a/**".to_string()],
        revisions: HashMap::new(),
        since_revision: None,
        origin: None,
    });
    fed.send(codec::encode(&sync).unwrap()).await.unwrap();

    let response = recv_msg(&mut fed_rx).await;
    assert!(response.is_some());
    match response.unwrap() {
        Message::Error(err) => {
            assert_eq!(err.code, 403, "wider sync pattern must be rejected");
        }
        other => panic!("expected Error(403), got: {:?}", other),
    }

    // Re-declare with exact path
    declare_and_ack(&fed, &mut fed_rx, vec!["/site-a/exact".to_string()]).await;

    // Try to sync /site-a/** -> should be rejected
    let sync = Message::FederationSync(FederationSyncMessage {
        op: FederationOp::RequestSync,
        patterns: vec!["/site-a/**".to_string()],
        revisions: HashMap::new(),
        since_revision: None,
        origin: None,
    });
    fed.send(codec::encode(&sync).unwrap()).await.unwrap();

    let response = recv_msg(&mut fed_rx).await;
    assert!(response.is_some());
    match response.unwrap() {
        Message::Error(err) => {
            assert_eq!(err.code, 403);
        }
        other => panic!("expected Error(403) for exact->globstar, got: {:?}", other),
    }

    handle.abort();
}

// ── FED-08: Subscription accumulation ──────────────────────────────────
/// Three-phase test: (1) declare /sensors/**, verify data received.
/// (2) Re-declare to /audio/** only, verify /sensors data NOT received.
/// (3) Verify /audio data IS received. Proves old subs were cleaned.
#[tokio::test]
async fn test_fed_08_subscription_accumulation() {
    let (url, handle) = setup_router().await;

    let (fed, mut fed_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&fed, &mut fed_rx, "Fed Peer").await;

    let (setter, mut setter_rx) = WebSocketTransport::connect(&url).await.unwrap();
    normal_handshake(&setter, &mut setter_rx, "Setter").await;

    // Phase 1: Declare /sensors/**, verify data is received
    declare_and_ack(&fed, &mut fed_rx, vec!["/sensors/**".to_string()]).await;

    let set1 = Message::Set(SetMessage {
        address: "/sensors/temp".to_string(),
        value: Value::Float(22.5),
        revision: None,
        lock: false,
        unlock: false,
    });
    setter.send(codec::encode(&set1).unwrap()).await.unwrap();
    let _ = recv_msg(&mut setter_rx).await; // ACK

    let phase1 = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = fed_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/sensors/temp" {
                            return s.value.clone();
                        }
                    }
                }
            }
        }
    })
    .await;
    assert!(
        phase1.is_ok(),
        "Phase 1: peer with /sensors/** must receive /sensors/temp"
    );

    // Phase 2: Re-declare to /audio/** only (replaces /sensors/**)
    declare_and_ack(&fed, &mut fed_rx, vec!["/audio/**".to_string()]).await;

    let set2 = Message::Set(SetMessage {
        address: "/sensors/temp".to_string(),
        value: Value::Float(23.0),
        revision: None,
        lock: false,
        unlock: false,
    });
    setter.send(codec::encode(&set2).unwrap()).await.unwrap();
    let _ = recv_msg(&mut setter_rx).await; // ACK

    let phase2 = timeout(Duration::from_millis(500), async {
        loop {
            if let Some(TransportEvent::Data(data)) = fed_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/sensors/temp" {
                            return true;
                        }
                    }
                }
            }
        }
    })
    .await;
    assert!(
        phase2.is_err(),
        "Phase 2: peer must NOT receive /sensors data after re-declaring to /audio"
    );

    // Phase 3: Verify /audio data IS received
    let set3 = Message::Set(SetMessage {
        address: "/audio/level".to_string(),
        value: Value::Float(0.8),
        revision: None,
        lock: false,
        unlock: false,
    });
    setter.send(codec::encode(&set3).unwrap()).await.unwrap();
    let _ = recv_msg(&mut setter_rx).await; // ACK

    let phase3 = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = fed_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/audio/level" {
                            return s.value.clone();
                        }
                    }
                }
            }
        }
    })
    .await;
    assert!(
        phase3.is_ok(),
        "Phase 3: peer with /audio/** must receive /audio/level"
    );
    assert_eq!(
        phase3.unwrap(),
        Value::Float(0.8),
        "Phase 3: received value must match"
    );

    handle.abort();
}

// ── FED-09: Unauthenticated federation ─────────────────────────────────
/// In authenticated router mode, federation HELLO with no token must be
/// rejected with error code 300 and "Authentication required" message.
/// Connection must be closed after the error.
#[tokio::test]
async fn test_fed_09_unauthenticated_federation() {
    use clasp_core::SecurityMode;

    let port = find_available_port().await;
    let addr = format!("127.0.0.1:{}", port);

    let router = Router::new(RouterConfig {
        features: vec!["param".to_string(), "federation".to_string()],
        security_mode: SecurityMode::Authenticated,
        ..Default::default()
    });

    let handle = {
        let addr = addr.clone();
        tokio::spawn(async move {
            let _ = router.serve_websocket(&addr).await;
        })
    };
    tokio::time::sleep(Duration::from_millis(100)).await;

    let url = format!("ws://{}", addr);
    let (fed, mut fed_rx) = WebSocketTransport::connect(&url).await.unwrap();

    // Send HELLO with federation feature but no auth token
    let hello = Message::Hello(HelloMessage {
        version: 2,
        name: "Unauth-Peer".to_string(),
        features: vec!["param".to_string(), "federation".to_string()],
        capabilities: None,
        token: None,
    });
    fed.send(codec::encode(&hello).unwrap()).await.unwrap();

    // Collect the first meaningful response
    let mut got_error = false;
    let mut error_code = 0u16;
    let mut error_message = String::new();
    let mut sent_declare = false;

    let _ = timeout(Duration::from_secs(2), async {
        loop {
            match fed_rx.recv().await {
                Some(TransportEvent::Data(data)) => {
                    if let Ok((msg, _)) = codec::decode(&data) {
                        match msg {
                            Message::Welcome(_) if !sent_declare => {
                                // Got WELCOME, try to declare namespaces
                                sent_declare = true;
                                let declare = Message::FederationSync(FederationSyncMessage {
                                    op: FederationOp::DeclareNamespaces,
                                    patterns: vec!["/site-a/**".to_string()],
                                    revisions: HashMap::new(),
                                    since_revision: None,
                                    origin: Some("unauth-peer".to_string()),
                                });
                                fed.send(codec::encode(&declare).unwrap()).await.unwrap();
                            }
                            Message::Error(err) => {
                                got_error = true;
                                error_code = err.code;
                                error_message = err.message.clone();
                                return;
                            }
                            _ => {}
                        }
                    }
                }
                Some(TransportEvent::Disconnected { .. }) | None => return,
                _ => {} // Connected, Error events — skip
            }
        }
    })
    .await;

    assert!(
        got_error,
        "authenticated router must send an Error message for unauthenticated federation"
    );
    assert_eq!(
        error_code, 300,
        "error code must be 300 (auth error), got: {}",
        error_code
    );
    assert!(
        error_message.contains("uthenti"),
        "error message must mention authentication, got: {}",
        error_message
    );

    // Connection should be closed after the error
    let post_error = timeout(Duration::from_millis(500), async {
        loop {
            match fed_rx.recv().await {
                Some(TransportEvent::Data(data)) => {
                    if let Ok((msg, _)) = codec::decode(&data) {
                        return Some(msg);
                    }
                }
                Some(TransportEvent::Disconnected { .. }) | None => return None,
                _ => {} // Connected, Error events — skip
            }
        }
    })
    .await;

    // Either timeout (connection dead) or explicit disconnect — both valid
    match post_error {
        Ok(None) => {} // Disconnected — correct
        Err(_) => {}   // Timeout — connection is dead, correct
        Ok(Some(msg)) => {
            panic!("expected connection closed after auth error, got: {:?}", msg);
        }
    }

    handle.abort();
}

// ── FED-10: State poisoning ────────────────────────────────────────────
/// Federation peer declares /site-a/**, sends SET to /site-b/secret
/// (outside namespace). Normal client subscribes to /site-b/** BEFORE
/// the poisoned SET. Verifies whether the poisoned SET is delivered.
#[tokio::test]
async fn test_fed_10_state_poisoning() {
    let (url, handle) = setup_router().await;

    // Normal client subscribes to /site-b/** FIRST
    let (checker, mut checker_rx) = WebSocketTransport::connect(&url).await.unwrap();
    normal_handshake(&checker, &mut checker_rx, "Checker").await;

    let sub = Message::Subscribe(clasp_core::SubscribeMessage {
        id: 1,
        pattern: "/site-b/**".to_string(),
        types: vec![],
        options: None,
    });
    checker.send(codec::encode(&sub).unwrap()).await.unwrap();
    // Wait for subscription ACK
    let _ = recv_msg(&mut checker_rx).await;

    // Federation peer declares /site-a/**
    let (fed, mut fed_rx) = WebSocketTransport::connect(&url).await.unwrap();
    federation_handshake(&fed, &mut fed_rx, "Fed Peer").await;
    declare_and_ack(&fed, &mut fed_rx, vec!["/site-a/**".to_string()]).await;

    // Federation peer sends SET to /site-b/secret (OUTSIDE declared namespace)
    let poison_set = Message::Set(SetMessage {
        address: "/site-b/secret".to_string(),
        value: Value::String("poisoned".to_string()),
        revision: None,
        lock: false,
        unlock: false,
    });
    fed.send(codec::encode(&poison_set).unwrap()).await.unwrap();

    // Wait for ACK/Error on the federation side
    let _ = recv_msg(&mut fed_rx).await;

    // Check if the subscriber receives the poisoned SET
    let poisoned = timeout(Duration::from_millis(500), async {
        loop {
            if let Some(TransportEvent::Data(data)) = checker_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/site-b/secret" {
                            return s.value.clone();
                        }
                    }
                }
            }
        }
    })
    .await;

    // Verify checker's subscription still works by sending a legitimate SET
    let (legit, mut legit_rx) = WebSocketTransport::connect(&url).await.unwrap();
    normal_handshake(&legit, &mut legit_rx, "Legit").await;
    let legit_set = Message::Set(SetMessage {
        address: "/site-b/check".to_string(),
        value: Value::String("legitimate".to_string()),
        revision: None,
        lock: false,
        unlock: false,
    });
    legit.send(codec::encode(&legit_set).unwrap()).await.unwrap();

    let legit_received = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = checker_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/site-b/check" {
                            return s.value.clone();
                        }
                    }
                }
            }
        }
    })
    .await;
    assert!(
        legit_received.is_ok(),
        "subscription must work — legitimate SET to /site-b/check must be received"
    );
    assert_eq!(
        legit_received.unwrap(),
        Value::String("legitimate".to_string())
    );

    // Document the finding based on whether poisoned SET was delivered
    if poisoned.is_ok() {
        // FINDING: Federation SETs outside declared namespace are still
        // broadcast to subscribers in open mode. Namespace declarations
        // are advisory only — scope enforcement requires authenticated mode.
        assert_eq!(
            poisoned.unwrap(),
            Value::String("poisoned".to_string()),
            "FINDING: poisoned value was delivered to subscriber"
        );
    } else {
        // Federation namespace enforcement blocks out-of-scope writes
        // (This would be the secure behavior)
    }

    handle.abort();
}
