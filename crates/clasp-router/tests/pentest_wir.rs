//! WIR — Wire Protocol Attack Tests
//!
//! Validates that the router survives malformed messages, type confusion,
//! oversized payloads, version mismatches, and rapid connect/disconnect
//! flooding without crashing or leaking resources.

#![cfg(feature = "websocket")]

use bytes::Bytes;
use clasp_core::{
    codec, HelloMessage, Message, SetMessage, SubscribeMessage, Value,
};
use clasp_router::{Router, RouterConfig};
use clasp_transport::{
    Transport, TransportEvent, TransportReceiver, TransportSender, WebSocketTransport,
};
use std::time::Duration;
use tokio::net::TcpListener;
use tokio::time::timeout;

async fn find_available_port() -> u16 {
    let listener = TcpListener::bind("127.0.0.1:0").await.unwrap();
    listener.local_addr().unwrap().port()
}

async fn recv_msg<R: TransportReceiver>(receiver: &mut R) -> Option<Message> {
    timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = receiver.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    return msg;
                }
            }
        }
    })
    .await
    .ok()
}

async fn normal_handshake<S: TransportSender, R: TransportReceiver>(
    sender: &S,
    receiver: &mut R,
    name: &str,
) {
    let hello = Message::Hello(HelloMessage {
        version: 2,
        name: name.to_string(),
        features: vec!["param".to_string()],
        capabilities: None,
        token: None,
    });
    sender.send(codec::encode(&hello).unwrap()).await.unwrap();

    let mut got_welcome = false;
    let mut got_snapshot = false;
    let deadline = timeout(Duration::from_secs(3), async {
        while !got_welcome || !got_snapshot {
            if let Some(TransportEvent::Data(data)) = receiver.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    match msg {
                        Message::Welcome(_) => got_welcome = true,
                        Message::Snapshot(_) => got_snapshot = true,
                        _ => {}
                    }
                }
            }
        }
    })
    .await;
    assert!(deadline.is_ok(), "normal handshake timed out");
}

async fn setup_router() -> (String, tokio::task::JoinHandle<()>) {
    let port = find_available_port().await;
    let addr = format!("127.0.0.1:{}", port);
    let router = Router::new(RouterConfig::default());

    let handle = {
        let addr = addr.clone();
        tokio::spawn(async move {
            let _ = router.serve_websocket(&addr).await;
        })
    };

    tokio::time::sleep(Duration::from_millis(100)).await;
    (format!("ws://{}", addr), handle)
}

// ── WIR-01: Malformed messages ─────────────────────────────────────────
/// Two paths: (a) attacker with NO handshake sends garbage → no welcome.
/// (b) attacker WITH handshake sends garbage → connection survives, can
/// send valid SET after. Good client unaffected in both cases.
#[tokio::test]
async fn test_wir_01_malformed_messages() {
    let (url, handle) = setup_router().await;

    // Connect a normal client first
    let (good, mut good_rx) = WebSocketTransport::connect(&url).await.unwrap();
    normal_handshake(&good, &mut good_rx, "Good Client").await;

    // (a) Attacker with NO handshake sends garbage → should not get Welcome
    {
        let (no_hs, mut no_hs_rx) = WebSocketTransport::connect(&url).await.unwrap();
        let _ = no_hs.send(Bytes::from_static(&[0xDE, 0xAD, 0xBE, 0xEF])).await;
        let _ = no_hs.send(Bytes::from_static(&[0x53, 0x01, 0xFF, 0xFF])).await;

        let response = timeout(Duration::from_millis(500), async {
            loop {
                if let Some(TransportEvent::Data(data)) = no_hs_rx.recv().await {
                    if let Ok((msg, _)) = codec::decode(&data) {
                        return msg;
                    }
                }
            }
        })
        .await;
        assert!(
            response.is_err(),
            "attacker with no handshake must not receive Welcome or any valid message"
        );
    }

    // (b) Attacker WITH handshake sends garbage → connection survives
    {
        let (hs_atk, mut hs_atk_rx) = WebSocketTransport::connect(&url).await.unwrap();
        normal_handshake(&hs_atk, &mut hs_atk_rx, "Attacker-HS").await;

        // Send garbage after handshake
        let _ = hs_atk.send(Bytes::from_static(&[0xDE, 0xAD, 0xBE, 0xEF])).await;
        let _ = hs_atk.send(Bytes::from_static(&[0x53, 0x01, 0x00, 0x01, 0xFF])).await;
        tokio::time::sleep(Duration::from_millis(100)).await;

        // Send a valid SET — connection should survive post-handshake errors
        let set = Message::Set(SetMessage {
            address: "/test/attacker_survived".to_string(),
            value: Value::Float(99.0),
            revision: None,
            lock: false,
            unlock: false,
        });
        hs_atk.send(codec::encode(&set).unwrap()).await.unwrap();

        let atk_response = recv_msg(&mut hs_atk_rx).await;
        assert!(
            atk_response.is_some(),
            "attacker connection should survive post-handshake garbage (non-fatal decode errors)"
        );
    }

    // Good client is still functional
    let set = Message::Set(SetMessage {
        address: "/test/after_attack".to_string(),
        value: Value::Float(1.0),
        revision: None,
        lock: false,
        unlock: false,
    });
    good.send(codec::encode(&set).unwrap()).await.unwrap();

    let response = recv_msg(&mut good_rx).await;
    assert!(
        response.is_some(),
        "good client must still be functional after all attacks"
    );

    handle.abort();
}

// ── WIR-02: Type confusion ─────────────────────────────────────────────
/// Second HELLO → assert client receives a second Welcome (new session).
/// WELCOME from client (wrong direction) → assert no error (silently ignored).
/// Valid SET after confusion → assert specific SET response.
#[tokio::test]
async fn test_wir_02_type_confusion() {
    let (url, handle) = setup_router().await;
    let (client, mut client_rx) = WebSocketTransport::connect(&url).await.unwrap();
    normal_handshake(&client, &mut client_rx, "Confuser").await;

    // Send a second HELLO after already having a session
    let hello2 = Message::Hello(HelloMessage {
        version: 2,
        name: "Second-Hello".to_string(),
        features: vec!["param".to_string()],
        capabilities: None,
        token: None,
    });
    client.send(codec::encode(&hello2).unwrap()).await.unwrap();

    // Implementation creates a new session → should receive a second Welcome
    let second_welcome = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = client_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    match msg {
                        Message::Welcome(_) => return msg,
                        Message::Snapshot(_) => continue, // Skip snapshot
                        _ => continue,
                    }
                }
            }
        }
    })
    .await;
    assert!(
        second_welcome.is_ok(),
        "second HELLO should produce a second Welcome (new session created)"
    );

    // Drain any snapshot that follows
    let _ = timeout(Duration::from_millis(200), async {
        loop {
            if let Some(TransportEvent::Data(data)) = client_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if matches!(msg, Message::Snapshot(_)) {
                        return;
                    }
                }
            }
        }
    }).await;

    // Send a WELCOME (client -> server, wrong direction)
    let welcome = Message::Welcome(clasp_core::WelcomeMessage {
        version: 2,
        session: "fake-session".to_string(),
        name: "Fake".to_string(),
        features: vec![],
        time: 0,
        token: None,
    });
    client.send(codec::encode(&welcome).unwrap()).await.unwrap();

    // Implementation handles via `_ => MessageResult::None` — no error sent
    let error_after_welcome = timeout(Duration::from_millis(300), async {
        loop {
            if let Some(TransportEvent::Data(data)) = client_rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if matches!(msg, Message::Error(_)) {
                        return msg;
                    }
                }
            }
        }
    })
    .await;
    assert!(
        error_after_welcome.is_err(),
        "WELCOME from client should be silently ignored (no error response)"
    );

    // Valid SET after confusion → must get a specific response
    let set = Message::Set(SetMessage {
        address: "/test/confusion".to_string(),
        value: Value::Float(42.0),
        revision: None,
        lock: false,
        unlock: false,
    });
    client.send(codec::encode(&set).unwrap()).await.unwrap();

    let response = recv_msg(&mut client_rx).await;
    assert!(response.is_some(), "must get response to valid SET after type confusion");
    let msg = response.unwrap();
    assert!(
        matches!(msg, Message::Set(_) | Message::Ack(_)),
        "response to SET must be Set or Ack, got: {:?}",
        msg
    );

    handle.abort();
}

// ── WIR-03: Oversized payloads ─────────────────────────────────────────
/// Codec boundary test: >65535 byte value → PayloadTooLarge error.
/// Just-under-limit value succeeds. Router survives oversized attempts.
#[tokio::test]
async fn test_wir_03_oversized_payloads() {
    use clasp_core::Error;

    let (url, handle) = setup_router().await;

    // Codec-level boundary test: value > 65535 bytes → PayloadTooLarge
    {
        let oversized_val = "X".repeat(66_000);
        let set = Message::Set(SetMessage {
            address: "/test/oversized".to_string(),
            value: Value::String(oversized_val),
            revision: None,
            lock: false,
            unlock: false,
        });

        let result = codec::encode(&set);
        assert!(
            result.is_err(),
            "encoding >65535 byte value must fail with PayloadTooLarge"
        );
        let err = result.unwrap_err();
        let err_str = format!("{}", err);
        assert!(
            err_str.contains("too large") || err_str.contains("payload"),
            "error must mention payload size, got: {}",
            err_str
        );
    }

    // Just-under-limit value should succeed at codec level
    {
        let ok_val = "Y".repeat(60_000);
        let set = Message::Set(SetMessage {
            address: "/test/ok_size".to_string(),
            value: Value::String(ok_val),
            revision: None,
            lock: false,
            unlock: false,
        });

        let result = codec::encode(&set);
        assert!(
            result.is_ok(),
            "encoding ~60KB value should succeed (under 65535 limit)"
        );
    }

    // Router-level: send a large HELLO name, router handles gracefully
    {
        let (client, mut rx) = WebSocketTransport::connect(&url).await.unwrap();

        let large_name = "A".repeat(10_000);
        let hello = Message::Hello(HelloMessage {
            version: 2,
            name: large_name,
            features: vec!["param".to_string()],
            capabilities: None,
            token: None,
        });

        match codec::encode(&hello) {
            Ok(bytes) => {
                let _ = client.send(bytes).await;
                // Router may accept (Welcome) or reject (Error)
                let response = recv_msg(&mut rx).await;
                if let Some(msg) = response {
                    assert!(
                        matches!(msg, Message::Welcome(_) | Message::Error(_)),
                        "response to large HELLO should be Welcome or Error, got: {:?}",
                        msg
                    );
                }
            }
            Err(_) => {
                // Encoding failed due to size limit — codec-level defense
            }
        }
    }

    // Verify router is still alive after all oversized attempts
    {
        let (client, mut rx) = WebSocketTransport::connect(&url).await.unwrap();
        normal_handshake(&client, &mut rx, "After-Oversize").await;

        let set = Message::Set(SetMessage {
            address: "/test/still_alive".to_string(),
            value: Value::Float(1.0),
            revision: None,
            lock: false,
            unlock: false,
        });
        client.send(codec::encode(&set).unwrap()).await.unwrap();
        let response = recv_msg(&mut rx).await;
        assert!(
            response.is_some(),
            "router must survive oversized payload attempts"
        );
    }

    handle.abort();
}

// ── WIR-04: Protocol version mismatch ──────────────────────────────────
/// v99 HELLO: assert response is Welcome (version-tolerant) or Error with
/// specific code. Raw JSON: no valid CLASP message received (decode fails).
/// Router survives both.
#[tokio::test]
async fn test_wir_04_protocol_version_mismatch() {
    let (url, handle) = setup_router().await;

    // v99 protocol version in HELLO → document whether version-tolerant or rejected
    {
        let (client, mut rx) = WebSocketTransport::connect(&url).await.unwrap();

        let hello = Message::Hello(HelloMessage {
            version: 99,
            name: "v99-client".to_string(),
            features: vec!["param".to_string()],
            capabilities: None,
            token: None,
        });
        client.send(codec::encode(&hello).unwrap()).await.unwrap();

        let response = timeout(Duration::from_secs(2), async {
            loop {
                if let Some(TransportEvent::Data(data)) = rx.recv().await {
                    if let Ok((msg, _)) = codec::decode(&data) {
                        return msg;
                    }
                }
            }
        })
        .await;

        assert!(
            response.is_ok(),
            "v99 HELLO should produce some response (Welcome or Error), not silence"
        );
        let msg = response.unwrap();
        assert!(
            matches!(msg, Message::Welcome(_) | Message::Error(_)),
            "v99 HELLO response must be Welcome (version-tolerant) or Error, got: {:?}",
            msg
        );
    }

    // Raw JSON (not a valid CLASP frame) → no valid CLASP message received
    {
        let (client, mut rx) = WebSocketTransport::connect(&url).await.unwrap();
        let json = r#"{"type":"HELLO","version":2,"name":"json-client","features":["param"]}"#;
        let _ = client.send(Bytes::from(json.as_bytes().to_vec())).await;

        let response = timeout(Duration::from_millis(500), async {
            loop {
                if let Some(TransportEvent::Data(data)) = rx.recv().await {
                    if let Ok((msg, _)) = codec::decode(&data) {
                        return msg;
                    }
                    // Raw bytes that don't decode — continue waiting
                }
            }
        })
        .await;
        assert!(
            response.is_err(),
            "raw JSON must not produce a valid CLASP response (not a valid frame)"
        );
    }

    // Verify router is still alive after version mismatch attacks
    {
        let (client, mut rx) = WebSocketTransport::connect(&url).await.unwrap();
        normal_handshake(&client, &mut rx, "After-Version-Tests").await;

        let set = Message::Set(SetMessage {
            address: "/test/version_ok".to_string(),
            value: Value::Float(1.0),
            revision: None,
            lock: false,
            unlock: false,
        });
        client.send(codec::encode(&set).unwrap()).await.unwrap();
        let response = recv_msg(&mut rx).await;
        assert!(
            response.is_some(),
            "router must survive version mismatch attacks"
        );
    }

    handle.abort();
}

// ── WIR-05: Replay flooding ───────────────────────────────────────────
/// 10 rapid connect/subscribe/disconnect cycles. After cycling, new client
/// gets clean state: subscribe to /**, SET a value, verify it arrives via
/// subscription. Proves state is clean after rapid cycling.
#[tokio::test]
async fn test_wir_05_replay_flooding() {
    let (url, handle) = setup_router().await;

    for i in 0..10 {
        let (client, mut rx) = WebSocketTransport::connect(&url).await.unwrap();
        normal_handshake(&client, &mut rx, &format!("Flood-{}", i)).await;

        // Subscribe
        let sub = Message::Subscribe(SubscribeMessage {
            id: i as u32,
            pattern: "/**".to_string(),
            types: vec![],
            options: None,
        });
        client.send(codec::encode(&sub).unwrap()).await.unwrap();

        // Quick SET
        let set = Message::Set(SetMessage {
            address: format!("/flood/{}", i),
            value: Value::Int(i as i64),
            revision: None,
            lock: false,
            unlock: false,
        });
        client.send(codec::encode(&set).unwrap()).await.unwrap();

        // Disconnect immediately
        let _ = client.close().await;
    }

    // Allow cleanup
    tokio::time::sleep(Duration::from_millis(200)).await;

    // New client: complete handshake, subscribe, SET, verify via subscription
    let (client, mut rx) = WebSocketTransport::connect(&url).await.unwrap();
    normal_handshake(&client, &mut rx, "After-Flood").await;

    // Subscribe to /**
    let sub = Message::Subscribe(SubscribeMessage {
        id: 100,
        pattern: "/**".to_string(),
        types: vec![],
        options: None,
    });
    client.send(codec::encode(&sub).unwrap()).await.unwrap();
    // Consume subscription ACK/initial data
    let _ = recv_msg(&mut rx).await;

    // SET a fresh value
    let set = Message::Set(SetMessage {
        address: "/test/post_flood".to_string(),
        value: Value::String("clean".to_string()),
        revision: None,
        lock: false,
        unlock: false,
    });
    client.send(codec::encode(&set).unwrap()).await.unwrap();

    // Should receive the SET back via subscription (proves subscription works)
    let received = timeout(Duration::from_secs(2), async {
        loop {
            if let Some(TransportEvent::Data(data)) = rx.recv().await {
                if let Ok((msg, _)) = codec::decode(&data) {
                    if let Message::Set(ref s) = msg {
                        if s.address == "/test/post_flood" {
                            return s.value.clone();
                        }
                    }
                }
            }
        }
    })
    .await;

    assert!(
        received.is_ok(),
        "post-flood client must receive SET via subscription (state is clean)"
    );
    assert_eq!(
        received.unwrap(),
        Value::String("clean".to_string()),
        "received value must match what was set"
    );

    handle.abort();
}
