//! RUL — Rules Engine Attack Tests
//!
//! Validates loop prevention, resource exhaustion bounds, cooldown
//! enforcement, and malformed input handling.

use clasp_core::{SignalType, Value};
use clasp_rules::{Rule, RuleAction, RulesEngine, Transform, Trigger};
use std::time::Duration;

fn make_rule(id: &str, pattern: &str, target: &str, value: Value) -> Rule {
    Rule {
        id: id.to_string(),
        name: format!("Test rule {}", id),
        enabled: true,
        trigger: Trigger::OnChange {
            pattern: pattern.to_string(),
        },
        conditions: vec![],
        actions: vec![RuleAction::Set {
            address: target.to_string(),
            value,
        }],
        cooldown: None,
    }
}

// ── RUL-01: Loop amplification ─────────────────────────────────────────
/// Three rules forming A->B, B->C, C->A. Origin "rule:*" must prevent
/// re-evaluation, breaking the cycle.
#[test]
fn test_rul_01_loop_amplification() {
    let mut engine = RulesEngine::new();

    // A -> B
    engine
        .add_rule(make_rule("r_ab", "/a", "/b", Value::Float(1.0)))
        .unwrap();
    // B -> C
    engine
        .add_rule(make_rule("r_bc", "/b", "/c", Value::Float(1.0)))
        .unwrap();
    // C -> A
    engine
        .add_rule(make_rule("r_ca", "/c", "/a", Value::Float(1.0)))
        .unwrap();

    // First evaluation: external trigger at /a -> fires r_ab (produces /b action)
    let actions_1 = engine.evaluate("/a", &Value::Float(1.0), SignalType::Param, None, |_| None);
    assert_eq!(actions_1.len(), 1, "external trigger should fire r_ab");
    assert!(actions_1[0].origin.starts_with("rule:"));

    // Second evaluation: the action from r_ab sets /b, but origin is "rule:r_ab"
    // This must be blocked by loop prevention.
    let actions_2 = engine.evaluate(
        "/b",
        &Value::Float(1.0),
        SignalType::Param,
        Some(&actions_1[0].origin),
        |_| None,
    );
    assert!(
        actions_2.is_empty(),
        "rule-originated changes must be suppressed to prevent loops"
    );
}

// ── RUL-02: Rule count exhaustion ──────────────────────────────────────
/// 10K rules matching `/**`, single SET. Must complete within reasonable
/// time and produce correct number of actions.
#[test]
fn test_rul_02_rule_count_exhaustion() {
    let mut engine = RulesEngine::new();

    for i in 0..10_000 {
        engine
            .add_rule(Rule {
                id: format!("r{}", i),
                name: format!("Bulk rule {}", i),
                enabled: true,
                trigger: Trigger::OnChange {
                    pattern: "/**".to_string(),
                },
                conditions: vec![],
                actions: vec![RuleAction::Set {
                    address: format!("/output/{}", i),
                    value: Value::Float(1.0),
                }],
                cooldown: None,
            })
            .unwrap();
    }

    let start = std::time::Instant::now();
    let actions = engine.evaluate(
        "/sensor/motion",
        &Value::Bool(true),
        SignalType::Param,
        None,
        |_| None,
    );
    let elapsed = start.elapsed();

    assert_eq!(actions.len(), 10_000);
    assert!(
        elapsed < Duration::from_secs(5),
        "10K rule evaluation took {:?}, expected < 5s",
        elapsed
    );
}

// ── RUL-03: Trigger pattern injection ──────────────────────────────────
/// A rule with `/**` trigger fires for ALL addresses.
#[test]
fn test_rul_03_trigger_pattern_injection() {
    let mut engine = RulesEngine::new();
    engine
        .add_rule(make_rule(
            "catch_all",
            "/**",
            "/log",
            Value::String("triggered".to_string()),
        ))
        .unwrap();

    // Must fire for any address
    for addr in &["/a", "/a/b/c", "/x/y/z/w/v", "/sensors/temp/1"] {
        let actions = engine.evaluate(addr, &Value::Bool(true), SignalType::Param, None, |_| None);
        assert_eq!(
            actions.len(),
            1,
            "catch-all /** trigger must fire for address {}",
            addr
        );
    }
}

// ── RUL-04: Cooldown bypass ────────────────────────────────────────────
/// 60s cooldown: fire twice immediately, second must be suppressed.
#[test]
fn test_rul_04_cooldown_bypass() {
    let mut engine = RulesEngine::new();
    let mut rule = make_rule("r1", "/sensor/**", "/output", Value::Bool(true));
    rule.cooldown = Some(Duration::from_secs(60));
    engine.add_rule(rule).unwrap();

    // First fire: should succeed
    let actions_1 = engine.evaluate(
        "/sensor/motion",
        &Value::Bool(true),
        SignalType::Param,
        None,
        |_| None,
    );
    assert_eq!(actions_1.len(), 1, "first fire should succeed");

    // Immediate second fire: should be suppressed by cooldown
    let actions_2 = engine.evaluate(
        "/sensor/motion",
        &Value::Bool(true),
        SignalType::Param,
        None,
        |_| None,
    );
    assert!(
        actions_2.is_empty(),
        "second fire within 60s cooldown must be suppressed"
    );

    // Verify interval evaluation also respects cooldown
    let mut engine2 = RulesEngine::new();
    engine2
        .add_rule(Rule {
            id: "interval_cd".to_string(),
            name: "Interval with cooldown".to_string(),
            enabled: true,
            trigger: Trigger::OnInterval { seconds: 5 },
            conditions: vec![],
            actions: vec![RuleAction::Set {
                address: "/x".to_string(),
                value: Value::Null,
            }],
            cooldown: Some(Duration::from_secs(60)),
        })
        .unwrap();

    let a1 = engine2.evaluate_interval("interval_cd", |_| None);
    assert_eq!(a1.len(), 1);

    let a2 = engine2.evaluate_interval("interval_cd", |_| None);
    assert!(a2.is_empty(), "interval evaluation must respect cooldown");
}

// ── RUL-05: SetFromTrigger scope escape ────────────────────────────────
/// Rules engine produces actions with correct address, value, AND origin
/// tagged as "rule:{id}" so the router can enforce scope. Verifies the
/// contract the rules engine provides to the router for enforcement.
#[test]
fn test_rul_05_set_from_trigger_scope_escape() {
    let mut engine = RulesEngine::new();
    engine
        .add_rule(Rule {
            id: "copy_secret".to_string(),
            name: "Copy restricted to public".to_string(),
            enabled: true,
            trigger: Trigger::OnChange {
                pattern: "/secret/data".to_string(),
            },
            conditions: vec![],
            actions: vec![RuleAction::SetFromTrigger {
                address: "/public/data".to_string(),
                transform: Transform::Identity,
            }],
            cooldown: None,
        })
        .unwrap();

    let actions = engine.evaluate(
        "/secret/data",
        &Value::String("sensitive".to_string()),
        SignalType::Param,
        None,
        |_| None,
    );

    assert_eq!(actions.len(), 1);

    // Verify address and value are exactly what the rule specified (no mutation/injection)
    match &actions[0].action {
        RuleAction::Set { address, value } => {
            assert_eq!(
                address, "/public/data",
                "output address must match rule target"
            );
            assert_eq!(
                *value,
                Value::String("sensitive".to_string()),
                "output value must match trigger value (Identity transform)"
            );
        }
        _ => panic!("expected Set action from SetFromTrigger"),
    }

    // Critical: origin must be tagged as "rule:{id}" so the router can enforce scope
    assert!(
        actions[0].origin.starts_with("rule:"),
        "origin must start with 'rule:' for router scope enforcement, got: {}",
        actions[0].origin
    );
    assert_eq!(
        actions[0].origin, "rule:copy_secret",
        "origin must be exactly 'rule:{{rule_id}}'"
    );

    // Verify rule_id is also correctly propagated
    assert_eq!(actions[0].rule_id, "copy_secret");
}

// ── RUL-06: Malformed rules JSON ───────────────────────────────────────
/// Invalid JSON, wrong structure, missing fields must all fail gracefully.
#[test]
fn test_rul_06_malformed_rules_json() {
    // Invalid JSON
    let result = serde_json::from_str::<Vec<Rule>>("not json at all");
    assert!(result.is_err());

    // Empty array (valid but no rules)
    let result = serde_json::from_str::<Vec<Rule>>("[]");
    assert!(result.is_ok());
    assert!(result.unwrap().is_empty());

    // Wrong structure: array of numbers
    let result = serde_json::from_str::<Vec<Rule>>("[1, 2, 3]");
    assert!(result.is_err());

    // Missing required fields
    let result = serde_json::from_str::<Rule>(r#"{"id": "r1"}"#);
    assert!(result.is_err());

    // Wrong trigger type
    let result = serde_json::from_str::<Rule>(
        r#"{"id":"r1","name":"x","enabled":true,"trigger":"invalid","conditions":[],"actions":[{"Set":{"address":"/x","value":null}}]}"#,
    );
    assert!(result.is_err());

    // Validation: empty ID
    let mut engine = RulesEngine::new();
    let result = engine.add_rule(Rule {
        id: "".to_string(),
        name: "bad".to_string(),
        enabled: true,
        trigger: Trigger::OnChange {
            pattern: "/x".to_string(),
        },
        conditions: vec![],
        actions: vec![RuleAction::Set {
            address: "/y".to_string(),
            value: Value::Null,
        }],
        cooldown: None,
    });
    assert!(result.is_err(), "empty rule ID must be rejected");

    // Validation: no actions
    let result = engine.add_rule(Rule {
        id: "r_no_actions".to_string(),
        name: "no actions".to_string(),
        enabled: true,
        trigger: Trigger::OnChange {
            pattern: "/x".to_string(),
        },
        conditions: vec![],
        actions: vec![],
        cooldown: None,
    });
    assert!(result.is_err(), "rule with no actions must be rejected");
}

// ── RUL-07: Interval flood ─────────────────────────────────────────────
/// Interval-triggered actions must have "interval:{rule_id}" origin tagging
/// so they can be distinguished from user-triggered actions. This is critical
/// for the loop prevention mechanism.
#[test]
fn test_rul_07_interval_flood() {
    let mut engine = RulesEngine::new();

    for i in 0..10 {
        engine
            .add_rule(Rule {
                id: format!("int_{}", i),
                name: format!("Interval {}", i),
                enabled: true,
                trigger: Trigger::OnInterval { seconds: 10 },
                conditions: vec![],
                actions: vec![RuleAction::Set {
                    address: format!("/output/{}", i),
                    value: Value::Int(i),
                }],
                cooldown: None,
            })
            .unwrap();
    }

    // Also add an OnChange rule to verify origin distinction
    engine
        .add_rule(make_rule(
            "on_change_r",
            "/trigger",
            "/output/change",
            Value::Bool(true),
        ))
        .unwrap();

    let intervals = engine.interval_rules();
    assert_eq!(intervals.len(), 10);

    // Evaluate each interval rule and verify origin tagging
    for (id, _seconds) in &intervals {
        let actions = engine.evaluate_interval(id, |_| None);
        assert_eq!(
            actions.len(),
            1,
            "interval rule {} should produce 1 action",
            id
        );

        let action = &actions[0];
        assert!(
            action.origin.starts_with("interval:"),
            "interval action origin must start with 'interval:', got: {}",
            action.origin
        );
        assert_eq!(
            action.origin,
            format!("interval:{}", id),
            "interval action origin must be 'interval:{{rule_id}}'"
        );
    }

    // Evaluate an OnChange rule and verify its origin is different
    let change_actions = engine.evaluate(
        "/trigger",
        &Value::Bool(true),
        SignalType::Param,
        None,
        |_| None,
    );
    assert_eq!(change_actions.len(), 1);
    assert!(
        change_actions[0].origin.starts_with("rule:"),
        "OnChange action origin must start with 'rule:', got: {}",
        change_actions[0].origin
    );

    // The two origin prefixes are distinguishable
    assert_ne!(
        change_actions[0].origin.split(':').next().unwrap(),
        "interval",
        "OnChange action must NOT have 'interval' prefix"
    );
}
