//! ADM — Admin API Attack Tests
//!
//! Validates authentication bypass, privilege escalation, IDOR,
//! entity injection, wrong-key minting, and secret file permissions.

#![cfg(feature = "registry")]

use axum::body::Body;
use axum::http::{Request, StatusCode};
use clasp_core::security::{Action, CpskValidator, Scope, TokenInfo, TokenValidator};
use clasp_registry::{EntityKeypair, EntityStore, EntityType, MemoryEntityStore};
use http_body_util::BodyExt;
use std::sync::Arc;
use tower::ServiceExt;

use clasp_relay::registry::{registry_router, RegistryState};

fn hex_encode(bytes: &[u8]) -> String {
    bytes.iter().map(|b| format!("{:02x}", b)).collect()
}

fn make_test_state() -> (Arc<RegistryState>, Arc<CpskValidator>, Arc<dyn EntityStore>, String) {
    let store: Arc<dyn EntityStore> = Arc::new(MemoryEntityStore::new());
    let validator = Arc::new(CpskValidator::new());

    let admin_token = CpskValidator::generate_token();
    let scopes = vec![Scope::new(Action::Admin, "/**").unwrap()];
    let info = TokenInfo::new(admin_token.clone(), scopes)
        .with_subject("test-admin".to_string());
    validator.register(admin_token.clone(), info);

    let state = Arc::new(
        RegistryState::new(store.clone(), validator.clone())
            .with_trust_anchors(vec!["deadbeef".to_string()], 5),
    );

    (state, validator, store, admin_token)
}

fn make_app(state: Arc<RegistryState>) -> axum::Router {
    registry_router(state)
}

// ── ADM-01: Authentication bypass ──────────────────────────────────────
/// GET/POST endpoints with no Authorization header -> 401
#[tokio::test]
async fn test_adm_01_authentication_bypass() {
    let (state, _, _, _) = make_test_state();

    // GET /api/entities without auth -> 401
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("GET")
        .uri("/api/entities")
        .body(Body::empty())
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);

    // POST /api/entities without auth -> 401
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("POST")
        .uri("/api/entities")
        .header("content-type", "application/json")
        .body(Body::from(r#"{"entity_type":"device","name":"x","public_key":"aa"}"#))
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);

    // POST /api/entities/{id}/token without auth -> 401
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("POST")
        .uri("/api/entities/test-id/token")
        .header("content-type", "application/json")
        .body(Body::from(r#"{"keypair_hex":"aa"}"#))
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::UNAUTHORIZED);

    // GET /api/trust-anchors is public (no auth required) -> 200
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("GET")
        .uri("/api/trust-anchors")
        .body(Body::empty())
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
}

// ── ADM-02: Privilege escalation ───────────────────────────────────────
/// Non-admin CPSK token (read:/**) -> 403 on all admin endpoints
#[tokio::test]
async fn test_adm_02_privilege_escalation() {
    let (state, validator, _, _) = make_test_state();

    // Register a read-only token
    let read_token = CpskValidator::generate_token();
    let scopes = vec![Scope::new(Action::Read, "/**").unwrap()];
    let info = TokenInfo::new(read_token.clone(), scopes);
    validator.register(read_token.clone(), info);

    // GET /api/entities with read-only token -> 403
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("GET")
        .uri("/api/entities")
        .header("authorization", format!("Bearer {}", read_token))
        .body(Body::empty())
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::FORBIDDEN);

    // POST /api/entities with read-only token -> 403
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("POST")
        .uri("/api/entities")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", read_token))
        .body(Body::from(r#"{"entity_type":"device","name":"x","public_key":"aa"}"#))
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::FORBIDDEN);

    // Write-only token also -> 403 (needs admin)
    let write_token = CpskValidator::generate_token();
    let scopes = vec![Scope::new(Action::Write, "/**").unwrap()];
    let info = TokenInfo::new(write_token.clone(), scopes);
    validator.register(write_token.clone(), info);

    let app = make_app(state.clone());
    let req = Request::builder()
        .method("GET")
        .uri("/api/entities")
        .header("authorization", format!("Bearer {}", write_token))
        .body(Body::empty())
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::FORBIDDEN);
}

// ── ADM-03: IDOR entity operations ────────────────────────────────────
/// Entity-level token cannot access registry CRUD (requires admin:/**)
#[tokio::test]
async fn test_adm_03_idor_entity_operations() {
    let (state, validator, store, admin_token) = make_test_state();

    // Create an entity
    let keypair = EntityKeypair::generate().unwrap();
    let entity = keypair.to_entity(EntityType::Device, "target-device".to_string());
    store.create(&entity).await.unwrap();

    // Register a token scoped to a narrow path (not admin:/**)
    let entity_token = CpskValidator::generate_token();
    let scopes = vec![Scope::new(Action::Admin, "/devices/**").unwrap()];
    let info = TokenInfo::new(entity_token.clone(), scopes);
    validator.register(entity_token.clone(), info);

    // Try to list entities with entity-level token -> 403
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("GET")
        .uri("/api/entities")
        .header("authorization", format!("Bearer {}", entity_token))
        .body(Body::empty())
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(
        resp.status(),
        StatusCode::FORBIDDEN,
        "admin:/devices/** should not satisfy admin:/** check"
    );

    // Admin token should work
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("GET")
        .uri("/api/entities")
        .header("authorization", format!("Bearer {}", admin_token))
        .body(Body::empty())
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::OK);
}

// ── ADM-04: Entity injection ───────────────────────────────────────────
/// Auth boundary test: duplicate creation (409), creation with READ token (403),
/// creation with NO token (401).
#[tokio::test]
async fn test_adm_04_entity_injection() {
    let (state, validator, _, admin_token) = make_test_state();

    let keypair = EntityKeypair::generate().unwrap();
    let pub_hex = hex_encode(keypair.public_key_bytes());

    let body = serde_json::json!({
        "entity_type": "device",
        "name": "first-device",
        "public_key": pub_hex,
    });

    // First creation with admin token -> 201
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("POST")
        .uri("/api/entities")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", admin_token))
        .body(Body::from(serde_json::to_string(&body).unwrap()))
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(resp.status(), StatusCode::CREATED);

    // Duplicate creation with admin token -> 409 Conflict
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("POST")
        .uri("/api/entities")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", admin_token))
        .body(Body::from(serde_json::to_string(&body).unwrap()))
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(
        resp.status(),
        StatusCode::CONFLICT,
        "duplicate entity creation must return 409"
    );

    // Creation with READ token -> 403 Forbidden
    let read_token = CpskValidator::generate_token();
    let read_scopes = vec![Scope::new(Action::Read, "/**").unwrap()];
    let read_info = TokenInfo::new(read_token.clone(), read_scopes);
    validator.register(read_token.clone(), read_info);

    let new_keypair = EntityKeypair::generate().unwrap();
    let new_pub_hex = hex_encode(new_keypair.public_key_bytes());
    let new_body = serde_json::json!({
        "entity_type": "device",
        "name": "read-attempt",
        "public_key": new_pub_hex,
    });

    let app = make_app(state.clone());
    let req = Request::builder()
        .method("POST")
        .uri("/api/entities")
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", read_token))
        .body(Body::from(serde_json::to_string(&new_body).unwrap()))
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(
        resp.status(),
        StatusCode::FORBIDDEN,
        "creation with READ token must return 403"
    );

    // Creation with NO token -> 401 Unauthorized
    let app = make_app(state.clone());
    let req = Request::builder()
        .method("POST")
        .uri("/api/entities")
        .header("content-type", "application/json")
        .body(Body::from(serde_json::to_string(&new_body).unwrap()))
        .unwrap();
    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(
        resp.status(),
        StatusCode::UNAUTHORIZED,
        "creation with NO token must return 401"
    );
}

// ── ADM-05: Token minting with wrong key ───────────────────────────────
/// Entity A, mint with KeyB -> 403
#[tokio::test]
async fn test_adm_05_token_minting_wrong_key() {
    let (state, _, store, admin_token) = make_test_state();

    // Register entity with keypair A
    let keypair_a = EntityKeypair::generate().unwrap();
    let entity = keypair_a.to_entity(EntityType::Device, "device-a".to_string());
    store.create(&entity).await.unwrap();

    // Try to mint with keypair B's signing key
    let keypair_b = EntityKeypair::generate().unwrap();
    let wrong_key_hex = hex_encode(&keypair_b.signing_key.to_bytes());

    let app = make_app(state.clone());
    let body = serde_json::json!({ "keypair_hex": wrong_key_hex });
    let req = Request::builder()
        .method("POST")
        .uri(&format!("/api/entities/{}/token", entity.id))
        .header("content-type", "application/json")
        .header("authorization", format!("Bearer {}", admin_token))
        .body(Body::from(serde_json::to_string(&body).unwrap()))
        .unwrap();

    let resp = app.oneshot(req).await.unwrap();
    assert_eq!(
        resp.status(),
        StatusCode::FORBIDDEN,
        "minting with wrong key must be rejected"
    );
}

// ── ADM-06: Admin token file exposure ──────────────────────────────────
/// write_secret_file() creates files with 0o600 permissions (Unix only).
#[cfg(unix)]
#[tokio::test]
async fn test_adm_06_admin_token_file_exposure() {
    use std::os::unix::fs::PermissionsExt;

    let dir = tempfile::tempdir().unwrap();
    let path = dir.path().join("admin-token");

    // Replicate the write_secret_file logic from main.rs
    {
        use std::io::Write;
        use std::os::unix::fs::OpenOptionsExt;
        let mut file = std::fs::OpenOptions::new()
            .write(true)
            .create(true)
            .truncate(true)
            .mode(0o600)
            .open(&path)
            .unwrap();
        file.write_all(b"secret-admin-token-value").unwrap();
    }

    // Verify the file has restrictive permissions
    let metadata = std::fs::metadata(&path).unwrap();
    let mode = metadata.permissions().mode() & 0o777;
    assert_eq!(
        mode, 0o600,
        "secret file must have 0o600 permissions, got {:o}",
        mode
    );

    // Verify content is correct
    let content = std::fs::read_to_string(&path).unwrap();
    assert_eq!(content, "secret-admin-token-value");
}
