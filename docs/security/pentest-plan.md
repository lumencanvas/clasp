# Penetration Testing Plan -- CLASP Distributed Infrastructure

**Scope:** All distributed infrastructure crates added on `feat/distributed-infrastructure`: `clasp-caps`, `clasp-registry`, `clasp-journal`, `clasp-rules`, `clasp-federation`, plus the relay admin API and CLI admin tooling.

**Methodology:** Black-box and grey-box testing against a local CLASP router with all features enabled (`--features full`). Each test case describes the attack vector, expected behavior, and pass/fail criteria.

**Reference:** 12 security issues were found and fixed during development (see [Known Fixed Vulnerabilities](#appendix-known-fixed-vulnerabilities) appendix).

---

## Test Environment Setup

### Router Configuration

```bash
# Generate keys
clasp key generate --out root.key
clasp key generate --out child.key

# Start router with all features
clasp-relay \
    --port 7330 \
    --auth-port 7350 \
    --security-mode authenticated \
    --admin-token ./admin.token \
    --trust-anchor ./root.key \
    --cap-max-depth 5 \
    --registry-db entities.db \
    --journal-db journal.db \
    --rules-file rules.json \
    --features full
```

### Tools Required

| Tool | Purpose |
|------|---------|
| Custom Rust test harness | Direct message construction, binary protocol manipulation |
| `wscat` / `websocat` | Raw WebSocket interaction |
| `curl` | Admin API endpoint testing |
| `proptest` | Property-based testing for edge cases |
| `cargo-fuzz` | Fuzz testing for parsers and decoders |
| `ed25519-dalek` | Key generation and signature manipulation |
| `rmp-serde` | Direct MessagePack construction |

---

## Category 1: Capability Token Attacks (CRITICAL)

### CAP-01: Token Forgery

**Attack:** Construct a `cap_` token with a valid-looking structure but signed with an unknown key (not in trust anchors).

**Steps:**
1. Generate a new Ed25519 keypair not registered as a trust anchor
2. Create a root token with `admin:/**` scopes signed by this key
3. Send the token in HELLO to authenticate

**Expected:** Router rejects with `UntrustedIssuer`. Session not created.

### CAP-02: Scope Attenuation Bypass

**Attack:** Manually construct a child token with wider scopes than the parent by tampering with the serialized payload after signing.

**Steps:**
1. Create a valid root token with `read:/lights/**`
2. Delegate to a child with `read:/lights/**`
3. Modify the child's scopes to `admin:/**` in the raw msgpack before base64 encoding
4. Send the tampered token

**Expected:** Signature verification fails (`InvalidSignature`).

### CAP-03: Chain Depth Bypass

**Attack:** Create a delegation chain deeper than `max_depth` by constructing proofs manually.

**Steps:**
1. Set validator `max_depth = 3`
2. Create a chain of 4 delegations (depth 4)
3. Authenticate with the deepest token

**Expected:** Rejected with `ChainTooDeep { depth: 4, max: 3 }`.

### CAP-04: Proof Chain Manipulation

**Attack:** Remove intermediate proofs from the chain to make a deeply delegated token appear as a root token.

**Steps:**
1. Create root -> child -> grandchild chain
2. Strip the proofs array from the grandchild token
3. Re-sign with the grandchild's key

**Expected:** The grandchild's key is not a trust anchor, so rejected with `UntrustedIssuer`.

### CAP-05: Replay Attack

**Attack:** Capture a valid capability token and replay it after the original session closes.

**Steps:**
1. Create a valid token and authenticate
2. Close the session
3. Re-authenticate with the same token

**Expected:** Token is accepted (tokens are stateless, replay prevention relies on expiration and nonces). Verify the nonce field is present and unique per token.

### CAP-06: Nonce Collision

**Attack:** Generate many tokens and check for nonce collisions.

**Steps:**
1. Generate 100,000 tokens with the same parameters
2. Check all nonces for uniqueness (UUID v4)

**Expected:** Zero collisions (UUID v4 collision probability is negligible).

### CAP-07: Trust Anchor Injection

**Attack:** Attempt to add a trust anchor at runtime via the admin API.

**Steps:**
1. Authenticate with admin CPSK token
2. Try to modify trust anchors via REST API or SET message
3. Check if newly anchored tokens are accepted

**Expected:** Trust anchors are loaded at startup only. No runtime modification path exists.

### CAP-08: Malformed MessagePack

**Attack:** Send tokens with malformed msgpack payloads.

**Steps:**
1. Send `cap_` + valid base64 of random bytes
2. Send `cap_` + valid base64 of truncated msgpack
3. Send `cap_` + valid base64 of msgpack with wrong field types
4. Send `cap_` + invalid base64

**Expected:** All rejected with `Encoding` error. No panic or crash.

### CAP-09: Action Hierarchy Escalation

**Attack:** Attempt to escalate from `read` to `write` via delegation.

**Steps:**
1. Create a root token with `read:/lights/**`
2. Attempt to delegate a child with `write:/lights/**`

**Expected:** `delegate()` returns `AttenuationViolation`. Child token not created.

### CAP-10: Pattern Wildcard Injection

**Attack:** Use crafted patterns to escape scope restrictions.

**Steps:**
1. Create a token scoped to `write:/lights/*`
2. Attempt to SET `/lights/room1/../../admin/config`
3. Attempt to SET `/lights/**` (literal `**` in address)
4. Attempt to subscribe with scope `read:/lights/*` to `/lights/room1/sub/path`

**Expected:** Path traversal has no effect (CLASP addresses are not filesystem paths). Wildcard in address is treated literally. Subscription outside single-wildcard depth is rejected by scope check.

---

## Category 2: Entity Token Attacks (HIGH)

### ENT-01: Signature Bypass

**Attack:** Construct an entity token with a valid entity ID but signed by a different key.

**Steps:**
1. Register entity A with public key KeyA
2. Generate a different keypair KeyB
3. Mint a token claiming entity A's ID but signed with KeyB

**Expected:** Signature verification fails against entity A's stored public key.

### ENT-02: Status Race Condition

**Attack:** Mint a token for an active entity, then suspend/revoke the entity before the token is used.

**Steps:**
1. Create entity, mint token
2. Suspend the entity via admin API
3. Authenticate with the previously-minted token

**Expected:** Validator checks entity status on each validation. Suspended/revoked entities are rejected with `NotActive`.

### ENT-03: Suspended Entity Re-Activation

**Attack:** Attempt to use a token after entity is suspended, then re-activate and retry.

**Steps:**
1. Create entity, mint token, suspend entity
2. Attempt auth (should fail)
3. Re-activate entity via admin API
4. Attempt auth again

**Expected:** Auth fails while suspended, succeeds after re-activation. Validates that status is checked live, not cached.

### ENT-04: Non-Existent Entity

**Attack:** Construct a token for an entity ID that doesn't exist in the registry.

**Steps:**
1. Generate a keypair
2. Mint a token (entity not registered in store)
3. Authenticate

**Expected:** Validator returns `Invalid("entity not found")`.

### ENT-05: Malformed Token

**Attack:** Send malformed entity tokens.

**Steps:**
1. Send `ent_` + valid base64 of random bytes
2. Send `ent_` + truncated payload
3. Send `ent_` with wrong key length (not 32 bytes)
4. Send `ent_` with truncated signature (not 64 bytes)

**Expected:** All rejected with appropriate errors. No panic or crash.

### ENT-06: Token Replay After Suspension

**Attack:** Capture a valid entity token, suspend the entity, then replay.

**Steps:**
1. Mint token, authenticate successfully
2. Admin suspends the entity
3. Open new connection, replay the same token

**Expected:** Rejected because entity status is checked on each validation call.

### ENT-07: Cross-Store Attack

**Attack:** Register an entity in one store instance and attempt to validate its token against a different store.

**Steps:**
1. Create entity in store A
2. Mint token
3. Validate against store B (which doesn't have the entity)

**Expected:** Validator returns `Invalid("entity not found")`. Tokens are not portable across registries without entity migration.

---

## Category 3: Federation Attacks (CRITICAL)

### FED-01: Namespace Hijacking

**Attack:** Federation peer declares namespaces it doesn't own and attempts to receive/modify data in those namespaces.

**Steps:**
1. Connect as federation peer
2. DeclareNamespaces(["/admin/**", "/**"])
3. RequestSync("/**")

**Expected:** In authenticated mode, scope check rejects namespaces outside the peer's scopes. In open mode, the declaration is accepted but the peer only receives data for patterns it subscribes to.

### FED-02: Pattern Count Exhaustion

**Attack:** Send DeclareNamespaces with more than 1,000 patterns to exhaust memory.

**Steps:**
1. Connect as federation peer
2. DeclareNamespaces with 1,001 unique patterns

**Expected:** Rejected with 400 error. `MAX_FEDERATION_PATTERNS = 1000`.

### FED-03: Revision Vector Exhaustion

**Attack:** Send a RevisionVector with more than 10,000 entries.

**Steps:**
1. Connect as federation peer, declare valid namespace
2. Send RevisionVector with 10,001 address/revision pairs

**Expected:** Rejected with 400 error. `MAX_REVISION_ENTRIES = 10000`.

### FED-04: Loop Injection

**Attack:** Forward a message back to its origin router to create an infinite loop.

**Steps:**
1. Set up Hub + Leaf A + Leaf B
2. Leaf A sends SET with `origin: "leaf-a"`
3. Hub forwards to Leaf B
4. Modify Leaf B to forward back to Hub with `origin: "leaf-b"` (removing original origin)

**Expected:** Each hop sets its own origin. The hub checks `origin == peer.router_id` before forwarding. Without tampering, loops are prevented. With a malicious peer that strips origin, the hub would still not forward back to the originating peer.

### FED-05: Unauthorized Sync Request

**Attack:** Request sync for a pattern outside declared namespaces.

**Steps:**
1. Connect as federation peer
2. DeclareNamespaces(["/site-a/**"])
3. RequestSync("/site-b/**")

**Expected:** Rejected with 403. `federation_pattern_covered_by()` validates that the requested pattern is covered by a declared namespace.

### FED-06: Non-Federation Sync Attempt

**Attack:** Send FederationSync messages from a non-federation session.

**Steps:**
1. Connect as a regular CLASP client (no `"federation"` in HELLO features)
2. Send a FederationSync message

**Expected:** Rejected with 403 error. Only sessions with `federation_peer = true` can use FederationSync.

### FED-07: Pattern Coverage Bypass

**Attack:** Exploit edge cases in `federation_pattern_covered_by()` to access data outside declared namespaces.

**Steps:**
1. Declare `/site-a/*` (single level)
2. RequestSync `/site-a/**` (all depths)
3. Declare `/a/b` (exact path)
4. RequestSync `/a/**` (globstar)
5. Test empty patterns, root `/`, double slashes `//`

**Expected:** All attempts rejected. `federation_pattern_covered_by()` handles these edge cases (verified by 15 unit tests after the pattern matcher bypass fix).

### FED-08: Subscription Accumulation

**Attack:** Repeatedly call DeclareNamespaces to accumulate subscriptions without cleanup.

**Steps:**
1. Connect as federation peer
2. DeclareNamespaces(["/a/**"])
3. DeclareNamespaces(["/b/**"])
4. Repeat many times
5. Check total subscription count

**Expected:** Each DeclareNamespaces call cleans up previous federation subscriptions (IDs >= 50000) before creating new ones. Subscription count should not grow unboundedly.

### FED-09: Unauthenticated Federation

**Attack:** Connect as a federation peer to a router in authenticated mode without providing a valid token.

**Steps:**
1. Start router with `--security-mode authenticated`
2. Connect via WebSocket, send HELLO with `"federation"` feature but no token

**Expected:** Session created but with no scopes. DeclareNamespaces rejected because scope checks fail.

### FED-10: State Poisoning via Snapshot

**Attack:** Send a crafted snapshot response to overwrite state in namespaces the peer doesn't own.

**Steps:**
1. Connect as federation leaf
2. During sync, send SET messages for addresses outside declared namespaces
3. Check if the hub accepts them

**Expected:** The hub should only accept state changes within the peer's declared namespace subscriptions. Out-of-scope SET messages should be filtered or rejected.

---

## Category 4: Rules Engine Attacks (HIGH)

### RUL-01: Loop Amplification

**Attack:** Create rules that trigger each other in a chain, amplifying a single input into many outputs.

**Steps:**
1. Rule A: OnChange `/a` -> Set `/b`
2. Rule B: OnChange `/b` -> Set `/c`
3. Rule C: OnChange `/c` -> Set `/a`
4. SET `/a` to trigger the chain

**Expected:** Loop prevention via origin tagging. Actions with origin `"rule:*"` are not re-evaluated by the rules engine. The chain fires once per rule, not infinitely.

### RUL-02: Rule Count Exhaustion

**Attack:** Load thousands of rules to exhaust evaluation time.

**Steps:**
1. Load 10,000 rules all matching `/**`
2. Send a single SET message

**Expected:** Evaluate performance. Rules engine uses HashMap lookup and pattern matching per rule. Document acceptable degradation threshold.

### RUL-03: Trigger Pattern Injection

**Attack:** Use crafted patterns in rule triggers to match more addresses than intended.

**Steps:**
1. Create rule with trigger pattern `/**` (matches everything)
2. Send any SET message

**Expected:** Rule fires for every SET. This is by design (admins control rule definitions). Verify that rules loaded from files are validated.

### RUL-04: Cooldown Bypass

**Attack:** Attempt to bypass rule cooldowns by manipulating timestamps.

**Steps:**
1. Create rule with 60-second cooldown
2. Trigger the rule
3. Immediately trigger again

**Expected:** Second trigger ignored due to cooldown. Cooldown uses `Instant` (monotonic clock), not wall clock, so time manipulation doesn't help.

### RUL-05: SetFromTrigger Scope Escape

**Attack:** Create a rule that copies values from a restricted address to an unrestricted one.

**Steps:**
1. Create rule: OnChange `/restricted/sensor` -> SetFromTrigger `/public/leak`
2. Verify that the rule action executes with `origin: "rule:*"`

**Expected:** Rule actions bypass scope checks (rules are server-side, defined by admins). This is by design. Document that rule definitions are trusted and should be treated as privileged configuration.

### RUL-06: Malformed Rules JSON

**Attack:** Load rules from a malformed JSON file.

**Steps:**
1. Create rules.json with invalid JSON
2. Create rules.json with valid JSON but invalid rule structure
3. Create rules.json with missing required fields
4. Start the router

**Expected:** Router returns a clean error on startup (no panic). Invalid rules are rejected with descriptive error messages.

### RUL-07: Interval Flood

**Attack:** Create many OnInterval rules with very short intervals.

**Steps:**
1. Create 100 rules with `OnInterval { seconds: 1 }`
2. Each rule publishes an event
3. Monitor router CPU and message throughput

**Expected:** Document acceptable performance. Consider whether interval rules should have a minimum interval or count limit.

---

## Category 5: Journal Attacks (MEDIUM)

### JNL-01: Journal Tampering

**Attack:** Modify the SQLite journal database directly to alter recorded state.

**Steps:**
1. Stop the router
2. Modify journal entries in the SQLite database
3. Restart the router

**Expected:** The journal does not have cryptographic integrity checks. Tampered entries will be replayed as-is. Document that journal integrity relies on filesystem access control.

### JNL-02: Replay Message Access Control

**Attack:** Request replay of journal entries for addresses outside the client's scopes.

**Steps:**
1. Authenticate with scopes `read:/lights/**`
2. Request replay for `/admin/**`

**Expected:** Replay handler should filter entries by the client's read scopes. Verify that scope enforcement applies to replay responses.

### JNL-03: Storage Exhaustion

**Attack:** Send many SET/PUBLISH messages to fill the journal.

**Steps:**
1. Send millions of SET messages to unique addresses
2. Monitor disk usage (SQLite) or memory usage (MemoryJournal)

**Expected:** MemoryJournal evicts oldest entries when capacity is reached (ring buffer). SqliteJournal has no built-in limit but relies on disk space. Document recommended compaction strategy.

### JNL-04: Snapshot Corruption

**Attack:** Corrupt a saved snapshot in the SQLite database.

**Steps:**
1. Stop the router
2. Modify the snapshot JSON in the snapshots table
3. Restart and trigger snapshot restore

**Expected:** Deserialization error on corrupted JSON. Router should handle gracefully (log error, skip snapshot, replay from journal entries instead). No panic.

### JNL-05: Sequence Number Manipulation

**Attack:** Attempt to append entries with out-of-order sequence numbers.

**Steps:**
1. Directly call `journal.append()` with entries that have pre-set sequence numbers
2. Query entries and verify ordering

**Expected:** Sequence numbers are assigned by the journal (auto-increment), not by the caller. The `seq` field on input entries is ignored/overwritten.

---

## Category 6: Admin API Attacks (HIGH)

### ADM-01: Authentication Bypass

**Attack:** Access admin API endpoints without providing the admin token.

**Steps:**
1. `GET /api/entities` -- no Authorization header
2. `POST /api/entities` -- no Authorization header
3. `POST /api/entities/{id}/token` -- no Authorization header

**Expected:** 401 Unauthorized for all protected endpoints.

### ADM-02: Privilege Escalation

**Attack:** Access admin API endpoints with a non-admin token.

**Steps:**
1. Register a regular user with `write:/chat/**` scopes
2. Use that token to call admin endpoints

**Expected:** 403 Forbidden. Admin endpoints require `admin:/**` scope.

### ADM-03: IDOR on Entity Operations

**Attack:** Access or modify entities belonging to other users.

**Steps:**
1. Create entity A as admin
2. Create entity B as admin
3. Attempt to modify entity A using entity B's token

**Expected:** Entity CRUD operations are admin-only (require `admin:/**`). Regular entity tokens cannot modify the registry.

### ADM-04: Entity Injection

**Attack:** Create an entity with a crafted public key that collides with an existing entity's ID.

**Steps:**
1. Create entity A
2. Attempt to create entity B with the same EntityId (different public key)

**Expected:** `AlreadyExists` error. EntityId is derived from the public key, so different keys produce different IDs.

### ADM-05: Token Minting for Wrong Entity

**Attack:** Mint a token for entity A using entity B's signing key.

**Steps:**
1. Create entity A (pubkey KeyA) and entity B (pubkey KeyB)
2. POST `/api/entities/A/token` with KeyB's signing key

**Expected:** 403 error. The endpoint verifies that the signing key's derived public key matches the entity's stored public key.

### ADM-06: Admin Token File Exposure

**Attack:** Read the admin token file from the filesystem.

**Steps:**
1. Check file permissions on the admin token file
2. Attempt to read from a different user account

**Expected:** File has 0600 permissions (owner-only read/write). Written atomically via `write_secret_file()` to prevent TOCTOU window.

---

## Category 7: Pattern Matcher Attacks (HIGH)

### PAT-01: Glob Match Bypass

**Attack:** Exploit edge cases in `glob_match()` to bypass scope restrictions.

**Steps:**
1. Scope: `read:/lights/*` -- try subscribing to `/lights/room1/sub`
2. Scope: `write:/lights/**` -- try setting `/other/path`
3. Scope: `read:/a/b/c` -- try subscribing to `/a/b/c/d`

**Expected:** All out-of-scope operations rejected. `*` matches exactly one segment, `**` matches any depth.

### PAT-02: Wildcard in Address

**Attack:** Send SET messages with wildcards in the address (not the subscription pattern).

**Steps:**
1. SET `/lights/*` to value
2. SET `/lights/**` to value
3. SET `/lights/room*` to value

**Expected:** Wildcards in addresses are treated as literal characters. A SET to `/lights/*` sets a parameter with the literal name `*`, it does not fan out.

### PAT-03: Empty and Root Patterns

**Attack:** Test edge cases with empty strings and root patterns.

**Steps:**
1. Subscribe to `""` (empty string)
2. Subscribe to `/`
3. Subscribe to `//`
4. Subscribe to `/**`
5. Set scope to `admin:` (empty pattern)

**Expected:** Consistent behavior. Empty patterns should not match everything. `/**` matches all addresses.

### PAT-04: pattern_is_subset Edge Cases

**Attack:** Test the `pattern_is_subset()` function with adversarial inputs.

**Steps:**
1. `pattern_is_subset("/**", "/a/*")` -- should be false (child wider)
2. `pattern_is_subset("/a/**", "/a/*")` -- should be false (globstar wider than single)
3. `pattern_is_subset("/a/*/c", "/a/**")` -- should be true (under globstar)
4. `pattern_is_subset("/a/../b", "/a/**")` -- test path traversal
5. `pattern_is_subset("", "/**")` -- empty child

**Expected:** All return correct results. No panics on adversarial input.

### PAT-05: Subscription Scope Escape

**Attack:** Subscribe to a pattern wider than the client's read scope.

**Steps:**
1. Authenticate with `read:/lights/room1/**`
2. Subscribe to `/lights/**` (wider)
3. Subscribe to `/**` (everything)

**Expected:** Subscription rejected because the pattern is not covered by the client's read scopes.

---

## Category 8: Wire Protocol Attacks (MEDIUM)

### WIR-01: Malformed Messages

**Attack:** Send malformed binary messages to the router.

**Steps:**
1. Send random bytes
2. Send truncated CLASP binary messages
3. Send messages with invalid type codes
4. Send messages with length fields that don't match content

**Expected:** All gracefully handled. Connection may be closed but router does not crash. Other sessions are not affected.

### WIR-02: Type Confusion

**Attack:** Send messages with mismatched type codes and payloads.

**Steps:**
1. Send a SET message with a SUBSCRIBE payload
2. Send a HELLO message after the session is established
3. Send a WELCOME message from a client (server-only message)

**Expected:** Decoded as the declared type, which will fail deserialization or be rejected by the handler. No crash.

### WIR-03: Oversized Payloads

**Attack:** Send messages with very large payloads.

**Steps:**
1. Send SET with 10MB value
2. Send SUBSCRIBE with 10,000 pattern entries
3. Send HELLO with very long client name (1MB)

**Expected:** Router enforces message size limits or handles gracefully. Memory usage should be bounded.

### WIR-04: Protocol Version Mismatch

**Attack:** Send messages with unsupported protocol version fields.

**Steps:**
1. Send v2 binary format to v3 router
2. Send v99 (non-existent version)
3. Send JSON instead of binary

**Expected:** v2 is auto-detected and decoded (backward compatibility). Unknown versions return a codec error. JSON fallback depends on configuration.

### WIR-05: Replay Message Flooding

**Attack:** Request replay of the entire state store repeatedly.

**Steps:**
1. Authenticate
2. Subscribe to `/**`
3. Disconnect and reconnect, triggering snapshot replay
4. Repeat rapidly

**Expected:** Each reconnection triggers a snapshot. Rate limiting and session timeout should bound the cost. Document whether replay requests are rate-limited.

---

## Appendix: Known Fixed Vulnerabilities

These 12 issues were found and fixed during development on `feat/distributed-infrastructure`. Each pentest should verify the fix holds:

| # | Severity | Issue | Fix | Verify With |
|---|----------|-------|-----|-------------|
| 1 | BUG | Trust anchor file format mismatch (hex vs raw bytes) | Hex-decode on load | CAP-01, CAP-07 |
| 2 | HIGH | Admin token permissions silently dropped | Warning logged on failure | ADM-06 |
| 3 | MOD | No TLS warning on entity token minting API | Warning logged, doc added | ENT-01 |
| 4 | MOD | Federation subscription accumulation on re-declare | Cleanup before re-subscribe | FED-08 |
| 5 | MOD | `clasp token entity create` misleading name | Renamed to `keygen` | -- |
| 6 | CRIT | Federation namespace restriction missing | `federation_pattern_covered_by()` | FED-05, FED-07 |
| 7 | CRIT | Federation resource limits missing | MAX_FEDERATION_PATTERNS, MAX_REVISION_ENTRIES | FED-02, FED-03 |
| 8 | CRIT | Federation scope enforcement missing in auth mode | Scope checks added | FED-01, FED-09 |
| 9 | HIGH | Panics on bad config crash server | Result propagation | RUL-06, JNL-04 |
| 10 | HIGH | TOCTOU on secret file writes | `write_secret_file()` with 0600 | ADM-06 |
| 11 | CRIT | Federation feature missing from binary codec | Bit 0x04 added | FED-06 |
| 12 | CRIT | Pattern matcher bypass (`*` swallowing `**`) | Reordered segment walk | FED-07, PAT-04 |

---

## Test Execution Checklist

| Category | Tests | Priority | Status |
|----------|-------|----------|--------|
| 1. Capability Token Attacks | CAP-01 through CAP-10 | CRITICAL | Pending |
| 2. Entity Token Attacks | ENT-01 through ENT-07 | HIGH | Pending |
| 3. Federation Attacks | FED-01 through FED-10 | CRITICAL | Pending |
| 4. Rules Engine Attacks | RUL-01 through RUL-07 | HIGH | Pending |
| 5. Journal Attacks | JNL-01 through JNL-05 | MEDIUM | Pending |
| 6. Admin API Attacks | ADM-01 through ADM-06 | HIGH | Pending |
| 7. Pattern Matcher Attacks | PAT-01 through PAT-05 | HIGH | Pending |
| 8. Wire Protocol Attacks | WIR-01 through WIR-05 | MEDIUM | Pending |
| **Total** | **55 test cases** | | |
